/**
 * Generated by Apache Royale Compiler from XMLList.as
 * XMLList
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('XMLList');
/* Royale Dependency List: Namespace,QName,XML,org.apache.royale.debugging.throwError,org.apache.royale.language.toAttributeName,org.apache.royale.utils.Language*/




/**
 * @constructor
 * @param {Object=} expression
 */
XMLList = function(expression) {
  expression = typeof expression !== 'undefined' ? expression : null;
  
  this._xmlArray = [];
  this.XMLList_addIndex(0);
  if (expression != null)
    this.XMLList_parseExpression(expression);
};


/**
 * @private
 * @const
 * @type {RegExp}
 */
XMLList.xmlDecl = /^\s*<\?xml[^?]*\?>/im;


/**
 *  mimics the top-level XMLList function (supports 'this' correctly)
 *
 *  @royalesuppressexport
 *  @royaleignorecoercion XMLList
 * @param {*=} val
 * @return {XMLList}
 */
XMLList.conversion = function(val) {
  val = typeof val !== 'undefined' ? val : null;
  if (val && val.constructor == XMLList)
    return val;
  else
    return new XMLList(val);
};


/**
 * Compiler-only method to support null-safe, non-strict equality checks between XMLList and
 * 'unknown' type
 *
 * @asprivate
 * @royaleignorecoercion XMLList
 * @royaleignorecoercion Object
 * @royalesuppressexport
 * @param {XMLList} list
 * @param {*} other
 * @return {boolean}
 */
XMLList.mixedEquality = function(list, other) {
  if (list == null) {
    return other == null;
  }
  if (other === undefined) {
    return list.XMLList_isEmpty();
  }
  if (other instanceof XMLList) {
    return list.equals(other);
  }
  if (typeof(other) == 'boolean')
    other = ('' + other);
  return list == other;
};


/**
 * Compiler-only method to stringification, which avoids valueOf calls.
 *
 * @asprivate
 * @royalesuppressexport
 * @param {XMLList} list
 * @return {string}
 */
XMLList.coerce_string = function(list) {
  return org.apache.royale.utils.Language.string(list !== null ? String(list) : null);
};


/**
 * @nocollapse
 * @param {Array} arr
 * @return {XMLList}
 */
XMLList.fromArray = function(arr) {
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = (arr.length) >> 0;
  while (XMLList.counter < len)
    list.XMLList_addIndex((XMLList.counter + 1) >> 0);
  list._xmlArray = arr;
  return list;
};


/**
 * @royaleignorecoercion String
 * @royaleignorecoercion XMLList
 * @royaleignorecoercion XML
 * @private
 * @param {Object} expression
 */
XMLList.prototype.XMLList_parseExpression = function(expression) {
  if (org.apache.royale.utils.Language.is(expression, XMLList)) {
    this.targetObject = expression.targetObject;
    this.targetProperty = expression.targetProperty;
    var /** @type {number} */ len = expression.length();
    for (var /** @type {number} */ i = 0; i < len; i++) {
      this.append(expression[i]);
    }
  } else if (org.apache.royale.utils.Language.is(expression, XML)) {
    this.append(expression);
  } else {
    if (typeof(expression) === "string") {
      var /** @type {string} */ expstr = expression;
      if (expstr.indexOf("<>") == 0 && expstr.indexOf("</>") == expstr.length - 3)
        expression = expstr.substr(2, expstr.length - 5);
    }
    try {
      var /** @type {XML} */ item = new XML(expression);
      if (item.nodeKind() == 'text' && item.getValue() == '')
        return;
      this.append(item);
    } catch (e) {
      if (typeof(expression) === "string") {
        var /** @type {string} */ decl = org.apache.royale.utils.Language.string(XMLList.xmlDecl.exec(expression));
        if (decl)
          expression = expression.replace(decl, '');
        expression = "<root>" + expression + "</root>";
        try {
          var /** @type {XML} */ xml = new XML(expression);
          var /** @type {XMLList} */ list = xml.children();
          var /** @type {number} */ m = list.length();
          for (var /** @type {number} */ j = 0; j < m; j++) {
            this.append(list[j]);
          }
        } catch (e2) {
          throw e;
        }
      }
      else
        throw e;
    }
  }
};


/**
 * [[ResolveValue]] from the e4x spec
 *  @royaleignorecoercion QName
 *  @royaleignorecoercion XMLList
 * @private
 * @return {*}
 */
XMLList.prototype.XMLList_resolveValue = function() {
  if (this._xmlArray.length > 0)
    return this;
  if ((this.XMLList__targetObject == null || this.XMLList__targetProperty == null) || (org.apache.royale.utils.Language.is(this.XMLList__targetProperty, QName) && (this.XMLList__targetProperty.isAttribute || this.XMLList__targetProperty.localName == '*')))
    return null;
  var /** @type {*} */ base = (!this.XMLList__targetObject || org.apache.royale.utils.Language.is(this.XMLList__targetObject, XML)) ? this.XMLList__targetObject : this.XMLList__targetObject.XMLList_resolveValue();
  if (base == null)
    return null;
  var /** @type {XMLList} */ target = base.child(this.XMLList__targetProperty);
  if (target.length() == 0) {
    if (org.apache.royale.utils.Language.is(base, XMLList) && (base.length() > 1))
      return null;
    base.setChild(this.XMLList__targetProperty, '');
    target = base.child(this.XMLList__targetProperty);
  }
  return target;
};


/**
 * @protected
 * @type {Array}
 */
XMLList.prototype._xmlArray;


/**
 * @private
 * @type {number}
 */
XMLList.counter = -1;


/**
 * @private
 * @param {number} idx
 */
XMLList.prototype.XMLList_addIndex = function(idx) {
  var self = this;
  if (idx <= XMLList.counter)
    return;
  XMLList.counter = idx;
  var /** @type {string} */ idxStr = "" + idx;
  Object.defineProperty(XMLList.prototype, idxStr, {"get":function() {
    return this._xmlArray[idx];
  }, "set":function(newValue) {
    if (idx >= this._xmlArray.length)
      this.append(newValue);
    else
      this.replaceChildAt(idx, newValue);
  }, enumerable:true, configurable:true});
};


/**
 *
 * @royaleignorecoercion XMLList
 * @royaleignorecoercion XML
 * @private
 * @param {Object} content
 */
XMLList.prototype.XMLList_Append = function(content) {
  var /** @type {number} */ i = (this._xmlArray.length) >>> 0;
  var /** @type {number} */ n = 1;
  if (org.apache.royale.utils.Language.is(content, XMLList)) {
    var /** @type {XMLList} */ l = content;
    this.XMLList__targetObject = l.XMLList__targetObject;
    this.XMLList__targetProperty = l.XMLList__targetProperty;
    n = (l.length()) >>> 0;
    if (n == 0)
      return;
    for (var /** @type {number} */ j = 0; j < n; j++) {
      this._xmlArray[i + j] = l._xmlArray[j];
      this.XMLList_addIndex((i + j) >> 0);
    }
  } else {
    if (org.apache.royale.utils.Language.is(content, XML)) {
      this._xmlArray[i] = content;
      this.XMLList_addIndex((i) >> 0);
    }
  }
};


/**
 * @param {XML} child
 */
XMLList.prototype.append = function(child) {
  this._xmlArray[this._xmlArray.length] = child;
  this.XMLList_addIndex((this._xmlArray.length) >> 0);
  if (!this.XMLList__targetObject)
    return;
  if (!this.XMLList__targetProperty) {
    this.XMLList__targetObject.appendChild(child);
    return;
  }
  var /** @type {XMLList} */ objToAppend = this.XMLList__targetObject.child(this.XMLList__targetProperty);
  if (!objToAppend.length()) {
    this.XMLList__targetObject.appendChild(child);
    return;
  }
  this.XMLList__targetObject.insertChildAfter(objToAppend[objToAppend.length() - 1], child);
};


/**
 * @param {*} child
 * @return {XML}
 */
XMLList.prototype.appendChild = function(child) {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].appendChild(child);
  return null;
};


/**
 * Calls the attribute() method of each XML object and returns an XMLList object of the results.
 * 
 * @asparam attributeName
 * @asreturn an XMLList of matching attributes
 *
 *
 * @royaleignorecoercion XML
 * 
 * @param {*} attributeName
 * @return {XMLList}
 */
XMLList.prototype.attribute = function(attributeName) {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].attribute(attributeName);
  var /** @type {XMLList} */ retVal = new XMLList();
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {XMLList} */ list = this._xmlArray[i].attribute(attributeName);
    if (list.length())
      retVal.concat(list);
  }
  return retVal;
};


/**
 * Calls the attributes() method of each XML object and returns an XMLList object of attributes for each XML object.
 * 
 * @asreturn 
 * 
 * @return {XMLList}
 */
XMLList.prototype.attributes = function() {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].attributes();
  var /** @type {XMLList} */ retVal = new XMLList();
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {XMLList} */ list = this._xmlArray[i].attributes();
    if (list.length())
      retVal.concat(list);
  }
  return retVal;
};


/**
 * Calls the child() method of each XML object and returns an XMLList object that contains the results in order.
 * 
 * @asparam propertyName
 * @asreturn 
 * 
 * @param {Object} propertyName
 * @return {XMLList}
 */
XMLList.prototype.child = function(propertyName) {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].child(propertyName);
  var /** @type {XMLList} */ retVal = new XMLList();
  retVal.targetProperty = propertyName.toString();
  if (this.XMLList_isEmpty())
    retVal.targetObject = this;
  var /** @type {number} */ propNum = parseInt(propertyName, 10);
  if (propNum.toString() == propertyName) {
    if (propNum >= 0 && propNum < this._xmlArray.length) {
      retVal.append(this._xmlArray[propNum]);
      retVal.targetObject = this._xmlArray[propNum];
    }
    return retVal;
  }
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {XMLList} */ list = this._xmlArray[i].child(propertyName);
    if (list.length())
      retVal.concat(list);
  }
  return retVal;
};


/**
 * @return {number}
 */
XMLList.prototype.childIndex = function() {
  if (this.XMLList_isSingle())
    return (this._xmlArray[0].childIndex()) >> 0;
  throw new Error("childIndex can only be called on an XMLList with one item.");
};


/**
 * Calls the children() method of each XML object and returns an XMLList object that contains the results.
 * 
 * @asreturn 
 * 
 * @return {XMLList}
 */
XMLList.prototype.children = function() {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].children();
  var /** @type {XMLList} */ retVal = new XMLList();
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {XMLList} */ list = this._xmlArray[i].children();
    if (list.length())
      retVal.concat(list);
  }
  return retVal;
};


/**
 * Calls the comments() method of each XML object and returns an XMLList of comments.
 * @asreturn 
 * 
 * @return {XMLList}
 */
XMLList.prototype.comments = function() {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].comments();
  var /** @type {XMLList} */ retVal = new XMLList();
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {XMLList} */ list = this._xmlArray[i].comments();
    if (list.length())
      retVal.concat(list);
  }
  return retVal;
};


/**
 *
 * @asparam list
 * @asreturn this list concatenated with the contents of the list argument
 *
 * @asprivate
 * @royaleignorecoercion XMLList
 * @royaleignorecoercion XML
 * @param {*} list
 * @return {XMLList}
 */
XMLList.prototype.concat = function(list) {
  if (org.apache.royale.utils.Language.is(list, XML)) {
    this.append(list);
  } else {
    if (!org.apache.royale.utils.Language.is(list, XMLList))
      throw new TypeError("invalid type");
    var /** @type {Array} */ otherListContents = list._xmlArray;
    var /** @type {number} */ l = (otherListContents.length) >>> 0;
    for (var /** @type {number} */ i = 0; i < l; i++) {
      this.append(otherListContents[i]);
    }
  }
  return this;
};


/**
 * Checks whether the XMLList object contains an XML object that is equal to the given value parameter.
 * 
 * @asparam value
 * @asreturn 
 * 
 * @param {*} value
 * @return {boolean}
 */
XMLList.prototype.contains = function(value) {
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    if (this._xmlArray[i].contains(value))
      return true;
  }
  return false;
};


/**
 * Returns a copy of the given XMLList object.
 * 
 * @asreturn 
 * 
 * @return {XMLList}
 */
XMLList.prototype.copy = function() {
  var /** @type {XMLList} */ retVal = new XMLList();
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++)
    retVal.append(this._xmlArray[i].copy());
  return retVal;
};


/**
 * Returns all descendants (children, grandchildren, great-grandchildren, and so on) of the XML object that have the given name parameter.
 * 
 * @asparam name
 * @asreturn 
 * 
 * @param {Object=} name
 * @return {XMLList}
 */
XMLList.prototype.descendants = function(name) {
  name = typeof name !== 'undefined' ? name : "*";
  if (this.XMLList_isSingle())
    return this._xmlArray[0].descendants(name);
  var /** @type {XMLList} */ retVal = new XMLList();
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {XMLList} */ list = this._xmlArray[i].descendants(name);
    if (list.length())
      retVal.concat(list);
  }
  return retVal;
};


/**
 * Calls the elements() method of each XML object.
 * 
 * @asparam name
 * @asreturn 
 * 
 * @param {Object=} name
 * @return {XMLList}
 */
XMLList.prototype.elements = function(name) {
  name = typeof name !== 'undefined' ? name : "*";
  if (this.XMLList_isSingle())
    return this._xmlArray[0].elements(name);
  var /** @type {XMLList} */ retVal = new XMLList();
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {XMLList} */ list = this._xmlArray[i].elements(name);
    if (list.length())
      retVal.concat(list);
  }
  return retVal;
};


/**
 * @return {Array}
 */
XMLList.prototype.elementNames = function() {
  var /** @type {Array} */ retVal = [];
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  while (i < len)
    retVal.push(i++);
  return retVal;
};


/**
 *
 * @asparam list
 * @asreturn
 *
 * @royaleignorecoercion XMLList
 * @royaleignorecoercion XML
 * @param {*} list
 * @return {boolean}
 */
XMLList.prototype.equals = function(list) {
  if (list === undefined && this._xmlArray.length == 0)
    return true;
  if (list instanceof XMLList) {
    if (list !== this) {
      var /** @type {number} */ l = (this._xmlArray.length) >>> 0;
      var /** @type {Array} */ other = list._xmlArray;
      if (other.length != l)
        return false;
      for (var /** @type {number} */ i = 0; i < l; i++) {
        if (!this._xmlArray[i].equals(other[i]))
          return false;
      }
    }
    return true;
  }
  if (this.XMLList_isSingle())
    return this._xmlArray[0].equals(list);
  return false;
};


/**
 * @param {Function} callback
 * @return {XMLList}
 */
XMLList.prototype.filter = function(callback) {
  var /** @type {XMLList} */ list = new XMLList();
  for (var /** @type {number} */ i = 0; i < this._xmlArray.length; i++) {
    if (callback(this._xmlArray[i]))
      list.append(this._xmlArray[i]);
  }
  list.targetObject = this.XMLList__targetObject;
  list.targetProperty = this.XMLList__targetProperty;
  return list;
};


/**
 * @return {boolean}
 */
XMLList.prototype.hasComplexContent = function() {
  if (this.XMLList_isEmpty())
    return false;
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 1; i < len; i++) {
    if (this._xmlArray[i].hasComplexContent())
      return true;
  }
  return false;
};


/**
 * @override
 */
XMLList.prototype.hasOwnProperty = function(propertyName) {
  if (this.XMLList_isSingle())
    return !!(this._xmlArray[0].hasOwnProperty(propertyName));
  if (parseInt(propertyName, 10).toString() == propertyName) {
    return parseInt(propertyName, 10) < this._xmlArray.length;
  }
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 1; i < len; i++) {
    if (this._xmlArray[i].hasOwnProperty(propertyName))
      return true;
  }
  return false;
};


/**
 * Checks whether the XMLList object contains simple content.
 * 
 * @asreturn 
 * 
 * @return {boolean}
 */
XMLList.prototype.hasSimpleContent = function() {
  if (this.XMLList_isEmpty())
    return true;
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  if (len == 1)
    return !!(this._xmlArray[0].hasSimpleContent());
  for (var /** @type {number} */ i = 0; i < len; i++) {
    if (this._xmlArray[i].nodeKind() == 'element')
      return false;
  }
  return true;
};


/**
 * Returns the number of items in the XMLList.
 * 
 * @asreturn 
 * 
 * @return {number}
 */
XMLList.prototype.length = function() {
  return (this._xmlArray.length) >> 0;
};


/**
 * @return {QName}
 */
XMLList.prototype.name = function() {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].name();
  return null;
};


/**
 * Merges adjacent text nodes and eliminates empty text nodes for each of the following:
 * all text nodes in the XMLList, all the XML objects contained in the XMLList, and the descendants of all the XML objects in the XMLList.
 * 
 * @asreturn 
 * 
 * @return {XMLList}
 */
XMLList.prototype.normalize = function() {
  var /** @type {number} */ len = (this._xmlArray.length) >>> 0;
  var /** @type {XML} */ textAccumulator;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {XML} */ node = XML.conversion(this._xmlArray[i]);
    var /** @type {string} */ nodeKind = node.nodeKind();
    if (nodeKind == 'element') {
      node.normalize();
      textAccumulator = null;
    } else if (nodeKind == 'text') {
      if (textAccumulator) {
        textAccumulator.setValue(textAccumulator.getValue() + node.getValue());
        this.removeChildAt(i);
        i--;
        len--;
      } else {
        textAccumulator = node;
      }
    } else {
      textAccumulator = null;
    }
  }
  return this;
};


/**
 * Returns the parent of the XMLList object if all items in the XMLList object have the same parent.
 * 
 * @asreturn 
 * 
 * @return {Object}
 */
XMLList.prototype.parent = function() {
  if (this.XMLList_isEmpty())
    return undefined;
  var /** @type {XML} */ retVal = this._xmlArray[0].parent();
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 1; i < len; i++) {
    if (this._xmlArray[i].parent() != retVal)
      return undefined;
  }
  return retVal;
};


/**
 * @param {*} rightHand
 * @return {*}
 */
XMLList.prototype.plus = function(rightHand) {
  if (org.apache.royale.utils.Language.is(rightHand, XML) || org.apache.royale.utils.Language.is(rightHand, XMLList)) {
    var /** @type {XMLList} */ list = new XMLList();
    list.concat(this);
    list.concat(rightHand);
    if (org.apache.royale.utils.Language.is(rightHand, XML))
      list.targetObject = rightHand; else {
      list.targetObject = rightHand.targetObject;
      list.targetProperty = rightHand.targetProperty;
    }
    return list;
  }
  if (org.apache.royale.utils.Language.is(rightHand, String))
    return this.toString() + rightHand;
  if (org.apache.royale.utils.Language.is(rightHand, Number) && isNaN(rightHand))
    return NaN;
  var /** @type {string} */ thisString = this.toString();
  var /** @type {string} */ rhsString = rightHand.toString();
  if (isNaN(Number(thisString)) || isNaN(Number(rhsString)))
    return thisString + rhsString;
  return Number(thisString) + rightHand;
};


/**
 * If a name parameter is provided, lists all the children of the XMLList object that contain processing instructions with that name.
 * 
 * @asparam name
 * @asreturn 
 * 
 * @param {string=} name
 * @return {XMLList}
 */
XMLList.prototype.processingInstructions = function(name) {
  name = typeof name !== 'undefined' ? name : "*";
  if (this.XMLList_isSingle())
    return this._xmlArray[0].processingInstructions(name);
  var /** @type {XMLList} */ retVal = new XMLList();
  if (!name)
    return retVal;
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    if (this._xmlArray[i].nodeKind() != "processing-instruction")
      continue;
    if (name == "*") {
      retVal.append(this._xmlArray[i]);
    }
    else if (name == this._xmlArray[i].localName)
      retVal.append(this._xmlArray[i]);
  }
  return retVal;
};


/**
 * @param {*} child
 */
XMLList.prototype.removeChild = function(child) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  if (org.apache.royale.utils.Language.is(child, String)) {
    var /** @type {number} */ propNum = parseInt(child, 10);
    if (propNum.toString() == child) {
      this.removeChildAt((propNum) >> 0);
    } else if (this.XMLList_isSingle()) {
      this._xmlArray[0].removeChild(child);
    }
    return;
  }
  if (org.apache.royale.utils.Language.is(child, Number)) {
    i = (child) >> 0;
    this.removeChildAt(i);
    return;
  }
  if (this.XMLList_isSingle())
    this._xmlArray[0].removeChild(child); else if (org.apache.royale.utils.Language.is(child, XMLList)) {
    len = (child.length()) >> 0;
    for (i = 0; i < len; i++) {
      this.removeChild(child[i]);
    }
  } else if (org.apache.royale.utils.Language.is(child, XML)) {
    len = (this._xmlArray.length - 1) >> 0;
    for (i = len; i >= 0; i--) {
      if (this._xmlArray[i] == child) {
        this._xmlArray.splice(i, 1);
        if (child.hasAncestor(this.XMLList__targetObject))
          child.parent().removeChild(child);
      }
    }
  }
};


/**
 * @param {number} idx
 */
XMLList.prototype.removeChildAt = function(idx) {
  if (idx >= 0 && idx < this._xmlArray.length) {
    var /** @type {XML} */ child = this._xmlArray[idx];
    this._xmlArray.splice(idx, 1);
    if (child.hasAncestor(this.XMLList__targetObject))
      child.parent().removeChild(child);
  }
};


/**
 * @protected
 * @param {number} idx
 * @param {*} child
 */
XMLList.prototype.replaceChildAt = function(idx, child) {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {XML} */ childToReplace = this._xmlArray[idx];
  if (childToReplace && this.XMLList__targetObject) {
    this.XMLList__targetObject.replaceChildAt(childToReplace.childIndex(), child);
  }
  if (org.apache.royale.utils.Language.is(child, XML)) {
    this._xmlArray[idx] = child;
  } else if (org.apache.royale.utils.Language.is(child, XMLList)) {
    var /** @type {number} */ len = (child.length()) >> 0;
    for (i = 0; i < len; i++) {
      if (i == 0)
        this._xmlArray[idx] = child[i];
      else
        this._xmlArray.splice(idx + i, 0, child[i]);
    }
  }
  while (idx++ < this._xmlArray.length) {
    if (!this.hasOwnProperty(idx))
      this.XMLList_addIndex(idx);
  }
};


/**
 * @private
 * @type {*}
 */
XMLList.prototype.XMLList__targetObject;


/**
 * @private
 * @type {*}
 */
XMLList.prototype.XMLList__targetProperty;


/**
 * @royaleignorecoercion QName
 * @private
 * @param {XML} r
 * @return {XML}
 */
XMLList.prototype.XMLList_xmlFromProperty = function(r) {
  if (this.XMLList__targetProperty == null || this.XMLList__targetProperty == '*' || (org.apache.royale.utils.Language.is(this.XMLList__targetProperty, QName) && this.XMLList__targetProperty.localName == '*')) {
    return new XML();
  }
  var /** @type {XML} */ ret;
  var /** @type {string} */ str = org.apache.royale.utils.Language.as(this.XMLList__targetProperty, String);
  ret = new XML();
  ret.setParent(r);
  if (str && str.charAt(0) == '@' || (org.apache.royale.utils.Language.is(this.XMLList__targetProperty, QName) && this.XMLList__targetProperty.isAttribute)) {
    if (r.child(this.XMLList__targetProperty).length())
      return null;
    ret.setName(this.XMLList__targetProperty);
  } else {
    var /** @type {string} */ xmlStr = "<";
    if (org.apache.royale.utils.Language.is(this.XMLList__targetProperty, QName)) {
      if (this.XMLList__targetProperty.prefix)
        xmlStr += this.XMLList__targetProperty.prefix + "::";
      xmlStr += this.XMLList__targetProperty.localName + "/>";
    } else {
      xmlStr += this.XMLList__targetProperty + "/>";
    }
    ret = new XML(xmlStr);
  }
  return ret;
};


/**
 * @param {*} attr
 * @param {string} value
 * @return {string}
 */
XMLList.prototype.setAttribute = function(attr, value) {
  this.setChild(org.apache.royale.language.toAttributeName(attr), value);
  return value;
};


/**
 * @param {*} obj
 * @return {boolean}
 */
XMLList.prototype.hasAncestor = function(obj) {
  if (this.XMLList_isSingle())
    return !!(this._xmlArray[0].hasAncestor(obj));
  return false;
};


/**
 * @param {XML} child1
 * @param {XML} child2
 * @return {XML}
 */
XMLList.prototype.insertChildAfter = function(child1, child2) {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].insertChildAfter(child1, child2);
  return null;
};


/**
 * @param {XML} child1
 * @param {XML} child2
 * @return {XML}
 */
XMLList.prototype.insertChildBefore = function(child1, child2) {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].insertChildAfter(child1, child2);
  return null;
};


/**
 * @param {string=} prefix
 * @return {*}
 */
XMLList.prototype.namespace = function(prefix) {
  prefix = typeof prefix !== 'undefined' ? prefix : null;
  if (this.XMLList_isSingle())
    return this._xmlArray[0].namespace(prefix);
  return null;
};


/**
 * @return {string}
 */
XMLList.prototype.nodeKind = function() {
  if (this.XMLList_isSingle())
    return org.apache.royale.utils.Language.string(this._xmlArray[0].nodeKind());
  return null;
};


/**
 * @param {*} ns
 * @return {XML}
 */
XMLList.prototype.removeNamespace = function(ns) {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].removeNamespace(ns);
  return null;
};


/**
 * @param {Object} propertyName
 * @param {*} value
 * @return {*}
 */
XMLList.prototype.replace = function(propertyName, value) {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].replace(propertyName, value);
};


/**
 * [[Put]] from the e4X spec
 *
 * @royaleignorecoercion XML
 * @royaleignorecoercion XMLList
 * @param {*} elementName
 * @param {Object} elements
 * @return {Object}
 */
XMLList.prototype.setChild = function(elementName, elements) {
  var /** @type {Object} */ r;
  var /** @type {number} */ idx = org.apache.royale.utils.Language.uint(elementName);
  if (idx + '' == elementName + '') {
    if (this.XMLList__targetObject) {
      if (org.apache.royale.utils.Language.is(this.XMLList__targetObject, XMLList))
        r = this.targetObject.XMLList_resolveValue();
      else
        r = this.XMLList__targetObject;
      if (r == null)
        return null;
    } else {
      r = null;
    }
    if (idx >= this._xmlArray.length) {
      var /** @type {XML} */ xmlR = r;
      if (!r && org.apache.royale.utils.Language.is(r, XMLList)) {
        if (!r.XMLList_isSingle())
          return null;
        xmlR = r[0];
      }
      if (xmlR && xmlR.nodeKind() != 'element')
        return null;
      var /** @type {XML} */ y = this.XMLList_xmlFromProperty(xmlR);
      idx = (this._xmlArray.length) >>> 0;
      if (y.nodeKind() != 'attribute') {
        if (xmlR) {
          if (idx > 0) {
            var /** @type {number} */ j = 0;
            while (j < xmlR.getChildrenArray().length - 1 && xmlR.getChildrenArray()[j] !== this._xmlArray[idx - 1]) {
              j++;
            }
          } else {
            j = (xmlR.getChildrenArray().length - 1) >>> 0;
          }
          xmlR.insertChildAfter(xmlR.getChildrenArray()[j], y);
        }
        if (org.apache.royale.utils.Language.is(elements, XML))
          y.setName(elements.name());
        else if (org.apache.royale.utils.Language.is(elements, XMLList))
          y.setName(new QName(elements.XMLList__targetProperty));
      }
      this.XMLList_Append(y);
    }
    if (!(org.apache.royale.utils.Language.is(elements, XML) || org.apache.royale.utils.Language.is(elements, XMLList)) || (org.apache.royale.utils.Language.is(elements, XML) && (elements.nodeKind() == 'text' || elements.nodeKind() == 'attribute'))) {
      elements = elements + '';
    }
    if (this._xmlArray[idx].nodeKind() == 'attribute') {
      var /** @type {QName} */ z = this._xmlArray[idx].name();
      this._xmlArray[idx].parent().setAttribute(z, elements);
      var /** @type {XMLList} */ attr = this._xmlArray[idx].parent().attribute(z);
      this._xmlArray[idx] = attr[0];
      this.XMLList_addIndex((idx) >> 0);
    } else if (org.apache.royale.utils.Language.is(elements, XMLList)) {
      var /** @type {XMLList} */ c = new XMLList(elements);
      var /** @type {XML} */ parent = this._xmlArray[idx].parent();
      if (parent) {
        var /** @type {number} */ q = (parent.getChildrenArray().indexOf(this._xmlArray[idx])) >> 0;
        parent.replaceChildAt(q, c);
        for (j = 0; j < c._xmlArray.child('length') - 1; j++) {
          c.setChild(j, parent.getChildrenArray()[q + j]);
        }
      }
      if (c.length() == 0) {
        this._xmlArray.splice(idx, 1);
        for (j = idx; j < this.length() - 1; j++) {
          this.XMLList_addIndex((j) >> 0);
        }
      } else {
        var /** @type {number} */ l = (this._xmlArray.length) >>> 0;
        var /** @type {number} */ cl = (c.length() - 1) >>> 0;
        for (j = (l - 1) >>> 0; j > idx; j--) {
          this._xmlArray[j + cl] = this._xmlArray[j];
          this.XMLList_addIndex((j + cl) >> 0);
        }
        for (j = 0; j < cl; j++) {
          this._xmlArray[idx + j] = c[j];
          this.XMLList_addIndex((idx + j) >> 0);
        }
      }
    } else if (org.apache.royale.utils.Language.is(elements, XML) || this._xmlArray[idx].nodeKind() == 'text' || this._xmlArray[idx].nodeKind() == 'comment' || this._xmlArray[idx].nodeKind() == 'processing-instruction') {
      parent = this._xmlArray[idx].parent();
      if (parent) {
        q = (parent.getChildrenArray().indexOf(this._xmlArray[idx])) >> 0;
        parent.replaceChildAt(q, elements);
        elements = parent.getChildrenArray()[q];
      }
      if (typeof(elements) == 'string') {
        var /** @type {XML} */ t = new XML();
        t.setParent(this);
        t.setValue(elements + '');
        this._xmlArray[idx] = t;
      } else {
        this._xmlArray[idx] = elements;
      }
      this.XMLList_addIndex((idx) >> 0);
    } else {
      this._xmlArray[idx].setChild('*', elements);
    }
  } else {
    if (this._xmlArray.length <= 1) {
      if (this.XMLList_isEmpty()) {
        r = this.XMLList_resolveValue();
        if (r == null || r.length() != 1)
          return null;
        this.XMLList_Append(r);
      }
      this._xmlArray[0].setChild(elementName, elements);
    } else {
      throw new TypeError('Error #1089: Assignment to lists with more than one item is not supported.');
    }
  }
  return elements;
};


/**
 * @param {XML} parent
 */
XMLList.prototype.setParent = function(parent) {
  if (this.XMLList_isSingle())
    this._xmlArray[0].setParent(parent);
};


/**
 * @param {Object} value
 * @return {XML}
 */
XMLList.prototype.setChildren = function(value) {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].setChildren(value);
  return null;
};


/**
 * @param {string} name
 */
XMLList.prototype.setLocalName = function(name) {
  if (this.XMLList_isSingle())
    this._xmlArray[0].setLocalName(name);
};


/**
 * @param {string} name
 */
XMLList.prototype.setName = function(name) {
  if (this.XMLList_isSingle())
    this._xmlArray[0].setName(name);
};


/**
 * @param {Namespace} ns
 */
XMLList.prototype.setNamespace = function(ns) {
  if (this.XMLList_isSingle())
    this._xmlArray[0].setNamespace(ns);
};


/**
 * Calls the text() method of each XML object and returns an XMLList object that contains the results.
 * 
 * @asreturn 
 * 
 * @return {XMLList}
 */
XMLList.prototype.text = function() {
  if (this.XMLList_isSingle())
    return this._xmlArray[0].text();
  var /** @type {XMLList} */ retVal = new XMLList();
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {XMLList} */ list = this._xmlArray[i].text();
    if (list.length())
      retVal.concat(list);
  }
  return retVal;
};


/**
 * Returns the string representation of this object, formatted according to locale-specific conventions.
 * 
 * @asreturn 
 * 
 * @override
 */
XMLList.prototype.toLocaleString = function() {
  var /** @type {Array} */ retVal = [];
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {string} */ str = org.apache.royale.utils.Language.string(this._xmlArray[i].toLocaleString());
    if (str)
      retVal.push(str);
  }
  return retVal.join("\n");
};


/**
 * Returns a string representation of all the XML objects in an XMLList object.
 * 
 * @asreturn 
 *
 * @royaleignorecoercion XML
 * @return {string}
 */
XMLList.prototype.toString = function() {
  if (this.hasSimpleContent()) {
    var /** @type {number} */ len = (this._xmlArray.length) >> 0;
    var /** @type {string} */ cumulativeText = '';
    for (var /** @type {number} */ i = 0; i < len; i++) {
      var /** @type {XML} */ child = this._xmlArray[i];
      var /** @type {string} */ kind = child.nodeKind();
      if (kind != "comment" && kind != "processing-instruction") {
        cumulativeText += child.toString();
      }
    }
    return cumulativeText;
  }
  else
    return this.toXMLString();
};


/**
 * Returns a string representation of all the XML objects in an XMLList object.
 * 
 * @asreturn 
 * 
 * @return {string}
 */
XMLList.prototype.toXMLString = function() {
  var /** @type {Array} */ retVal = [];
  var /** @type {number} */ len = (this._xmlArray.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    var /** @type {string} */ str = org.apache.royale.utils.Language.string(this._xmlArray[i].toXMLString());
    if (str)
      retVal.push(str);
  }
  return retVal.join("\n");
};


/**
 * Returns the XMLList object.
 * @royaleignorecoercion XML
 * @royaleignorecoercion QName
 * 
 * @override
 */
XMLList.prototype.valueOf = function() {
  if (this.XMLList_isEmpty()) {
    var /** @type {XML} */ target = this.targetObject;
    if (!target)
      return undefined;
    var /** @type {QName} */ targetProp = this.targetProperty;
    if (targetProp)
      return undefined;
    return target.valueOf();
  }
  if (this.XMLList_isSingle())
    return this._xmlArray[0].valueOf();
  return this.toString();
};


/**
 * @param {string} name
 * @return {string}
 */
XMLList.prototype.anchor = function(name) {
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].anchor(name) : "");
};


/**
 * @param {number} index
 * @return {string}
 */
XMLList.prototype.charAt = function(index) {
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].charAt(index) : "");
};


/**
 * @param {number} index
 * @return {number}
 */
XMLList.prototype.charCodeAt = function(index) {
  return Number(this.XMLList_isSingle() ? this._xmlArray[0].charCodeAt(index) : -1);
};


/**
 * @param {number} pos
 * @return {number}
 */
XMLList.prototype.codePointAt = function(pos) {
  return Number(this.XMLList_isSingle() ? this._xmlArray[0].codePointAt(pos) : -1);
};


/**
 * @param {string} searchValue
 * @param {number=} fromIndex
 * @return {number}
 */
XMLList.prototype.indexOf = function(searchValue, fromIndex) {
  fromIndex = typeof fromIndex !== 'undefined' ? fromIndex : 0;
  return Number(this.XMLList_isSingle() ? this._xmlArray[0].indexOf(searchValue, fromIndex) : -1);
};


/**
 * @param {string} searchValue
 * @param {number=} fromIndex
 * @return {number}
 */
XMLList.prototype.lastIndexOf = function(searchValue, fromIndex) {
  fromIndex = typeof fromIndex !== 'undefined' ? fromIndex : 0;
  return Number(this.XMLList_isSingle() ? this._xmlArray[0].lastIndexOf(searchValue, fromIndex) : -1);
};


/**
 * @param {string} compareString
 * @param {*=} locales
 * @param {*=} options
 * @return {number}
 */
XMLList.prototype.localeCompare = function(compareString, locales, options) {
  locales = typeof locales !== 'undefined' ? locales : undefined;
  options = typeof options !== 'undefined' ? options : undefined;
  return Number(this.XMLList_isSingle() ? this._xmlArray[0].localeCompare(compareString, locales, options) : NaN);
};


/**
 * @param {*} regexp
 * @return {Array}
 */
XMLList.prototype.match = function(regexp) {
  return this.XMLList_isSingle() ? this._xmlArray[0].match(regexp) : null;
};


/**
 * @param {*} regexp
 * @return {number}
 */
XMLList.prototype.search = function(regexp) {
  return Number(this.XMLList_isSingle() ? this._xmlArray[0].search(regexp) : -1);
};


/**
 * @param {number} beginSlice
 * @param {*=} endSlice
 * @return {string}
 */
XMLList.prototype.slice = function(beginSlice, endSlice) {
  endSlice = typeof endSlice !== 'undefined' ? endSlice : undefined;
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].slice(beginSlice, endSlice) : null);
};


/**
 * @param {*=} separator
 * @param {*=} limit
 * @return {Array}
 */
XMLList.prototype.split = function(separator, limit) {
  separator = typeof separator !== 'undefined' ? separator : undefined;
  limit = typeof limit !== 'undefined' ? limit : undefined;
  return this.XMLList_isSingle() ? this._xmlArray[0].split(separator, limit) : null;
};


/**
 * @param {number} start
 * @param {*=} length
 * @return {string}
 */
XMLList.prototype.substr = function(start, length) {
  length = typeof length !== 'undefined' ? length : undefined;
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].substr(start, length) : null);
};


/**
 * @param {number} indexStart
 * @param {*=} indexEnd
 * @return {string}
 */
XMLList.prototype.substring = function(indexStart, indexEnd) {
  indexEnd = typeof indexEnd !== 'undefined' ? indexEnd : undefined;
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].substring(indexStart, indexEnd) : null);
};


/**
 * @return {string}
 */
XMLList.prototype.toLocaleLowerCase = function() {
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].toLocaleLowerCase() : null);
};


/**
 * @return {string}
 */
XMLList.prototype.toLocaleUpperCase = function() {
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].toLocaleUpperCase() : null);
};


/**
 * @return {string}
 */
XMLList.prototype.toLowerCase = function() {
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].toLowerCase() : null);
};


/**
 * @return {string}
 */
XMLList.prototype.toUpperCase = function() {
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].toUpperCase() : null);
};


/**
 * @return {string}
 */
XMLList.prototype.trim = function() {
  return org.apache.royale.utils.Language.string(this.XMLList_isSingle() ? this._xmlArray[0].trim() : null);
};


/**
 * @param {*=} fractionDigits
 * @return {number}
 */
XMLList.prototype.toExponential = function(fractionDigits) {
  fractionDigits = typeof fractionDigits !== 'undefined' ? fractionDigits : undefined;
  return Number(this.XMLList_isSingle() ? this._xmlArray[0].toExponential(fractionDigits) : NaN);
};


/**
 * @param {number=} digits
 * @return {number}
 */
XMLList.prototype.toFixed = function(digits) {
  digits = typeof digits !== 'undefined' ? digits : 0;
  return Number(this.XMLList_isSingle() ? this._xmlArray[0].toFixed(digits) : NaN);
};


/**
 * @param {*=} precision
 * @return {number}
 */
XMLList.prototype.toPrecision = function(precision) {
  precision = typeof precision !== 'undefined' ? precision : undefined;
  return Number(this.XMLList_isSingle() ? this._xmlArray[0].toPrecision(precision) : NaN);
};


/**
 * @private
 * @return {boolean}
 */
XMLList.prototype.XMLList_isEmpty = function() {
  return this._xmlArray.length == 0;
};


/**
 * @private
 * @return {boolean}
 */
XMLList.prototype.XMLList_isSingle = function() {
  return this._xmlArray.length == 1;
};


/**
 * This coerces single-item XMLList objects to XML for cases where the type is expected to be XML
 * @return {XML}
 */
XMLList.prototype.toXML = function() {
  if (this.XMLList_isSingle())
    return this._xmlArray[0];
  org.apache.royale.debugging.throwError("Incompatible assignment of XMLList to XML");
  return null;
};


/**
 * @return {string}
 */
XMLList.prototype.localName = function() {
  if (this.XMLList_isSingle())
    return org.apache.royale.utils.Language.string(this._xmlArray[0].localName());
  org.apache.royale.debugging.throwError("Incompatible assignment of XMLList to XML");
  return null;
};


/**
 * @nocollapse
 * @export
 * @type {*}
 */
XMLList.prototype.targetObject;


XMLList.prototype.get__targetObject = function() {
  return this.XMLList__targetObject;
};


XMLList.prototype.set__targetObject = function(value) {
  this.XMLList__targetObject = value;
};


/**
 * @nocollapse
 * @export
 * @type {*}
 */
XMLList.prototype.targetProperty;


XMLList.prototype.get__targetProperty = function() {
  return this.XMLList__targetProperty;
};


XMLList.prototype.set__targetProperty = function(value) {
  this.XMLList__targetProperty = value;
};


Object.defineProperties(XMLList.prototype, /** @lends {XMLList.prototype} */ {
/**
 * @type {*}
 */
targetObject: {
get: XMLList.prototype.get__targetObject,
set: XMLList.prototype.set__targetObject},
/**
 * @type {*}
 */
targetProperty: {
get: XMLList.prototype.get__targetProperty,
set: XMLList.prototype.set__targetProperty}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
XMLList.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'XMLList', qName: 'XMLList', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
XMLList.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'targetObject': { type: '*', access: 'readwrite', declaredBy: 'XMLList'},
        'targetProperty': { type: '*', access: 'readwrite', declaredBy: 'XMLList'}
      };
    },
    methods: function () {
      return {
        '|fromArray': { type: 'XMLList', declaredBy: 'XMLList', parameters: function () { return [ 'Array', false ]; }},
        'XMLList': { type: '', declaredBy: 'XMLList', parameters: function () { return [ 'Object', true ]; }},
        'append': { type: 'void', declaredBy: 'XMLList', parameters: function () { return [ 'XML', false ]; }},
        'appendChild': { type: 'XML', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'attribute': { type: 'XMLList', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'attributes': { type: 'XMLList', declaredBy: 'XMLList'},
        'child': { type: 'XMLList', declaredBy: 'XMLList', parameters: function () { return [ 'Object', false ]; }},
        'childIndex': { type: 'int', declaredBy: 'XMLList'},
        'children': { type: 'XMLList', declaredBy: 'XMLList'},
        'comments': { type: 'XMLList', declaredBy: 'XMLList'},
        'concat': { type: 'XMLList', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'contains': { type: 'Boolean', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'copy': { type: 'XMLList', declaredBy: 'XMLList'},
        'descendants': { type: 'XMLList', declaredBy: 'XMLList', parameters: function () { return [ 'Object', true ]; }},
        'elements': { type: 'XMLList', declaredBy: 'XMLList', parameters: function () { return [ 'Object', true ]; }},
        'elementNames': { type: 'Array', declaredBy: 'XMLList'},
        'equals': { type: 'Boolean', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'filter': { type: 'XMLList', declaredBy: 'XMLList', parameters: function () { return [ 'Function', false ]; }},
        'hasComplexContent': { type: 'Boolean', declaredBy: 'XMLList'},
        'hasOwnProperty': { type: 'Boolean', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'hasSimpleContent': { type: 'Boolean', declaredBy: 'XMLList'},
        'length': { type: 'int', declaredBy: 'XMLList'},
        'name': { type: 'QName', declaredBy: 'XMLList'},
        'normalize': { type: 'XMLList', declaredBy: 'XMLList'},
        'parent': { type: 'Object', declaredBy: 'XMLList'},
        'plus': { type: '*', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'processingInstructions': { type: 'XMLList', declaredBy: 'XMLList', parameters: function () { return [ 'String', true ]; }},
        'removeChild': { type: 'void', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'removeChildAt': { type: 'void', declaredBy: 'XMLList', parameters: function () { return [ 'int', false ]; }},
        'setAttribute': { type: 'String', declaredBy: 'XMLList', parameters: function () { return [ '*', false ,'String', false ]; }},
        'hasAncestor': { type: 'Boolean', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'insertChildAfter': { type: 'XML', declaredBy: 'XMLList', parameters: function () { return [ 'XML', false ,'XML', false ]; }},
        'insertChildBefore': { type: 'XML', declaredBy: 'XMLList', parameters: function () { return [ 'XML', false ,'XML', false ]; }},
        'namespace': { type: '*', declaredBy: 'XMLList', parameters: function () { return [ 'String', true ]; }},
        'nodeKind': { type: 'String', declaredBy: 'XMLList'},
        'removeNamespace': { type: 'XML', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'replace': { type: '*', declaredBy: 'XMLList', parameters: function () { return [ 'Object', false ,'*', false ]; }},
        'setChild': { type: 'Object', declaredBy: 'XMLList', parameters: function () { return [ '*', false ,'Object', false ]; }},
        'setParent': { type: 'void', declaredBy: 'XMLList', parameters: function () { return [ 'XML', false ]; }},
        'setChildren': { type: 'XML', declaredBy: 'XMLList', parameters: function () { return [ 'Object', false ]; }},
        'setLocalName': { type: 'void', declaredBy: 'XMLList', parameters: function () { return [ 'String', false ]; }},
        'setName': { type: 'void', declaredBy: 'XMLList', parameters: function () { return [ 'String', false ]; }},
        'setNamespace': { type: 'void', declaredBy: 'XMLList', parameters: function () { return [ 'Namespace', false ]; }},
        'text': { type: 'XMLList', declaredBy: 'XMLList'},
        'toLocaleString': { type: 'String', declaredBy: 'XMLList'},
        'toString': { type: 'String', declaredBy: 'XMLList'},
        'toXMLString': { type: 'String', declaredBy: 'XMLList'},
        'valueOf': { type: '*', declaredBy: 'XMLList'},
        'anchor': { type: 'String', declaredBy: 'XMLList', parameters: function () { return [ 'String', false ]; }},
        'charAt': { type: 'String', declaredBy: 'XMLList', parameters: function () { return [ 'Number', false ]; }},
        'charCodeAt': { type: 'Number', declaredBy: 'XMLList', parameters: function () { return [ 'Number', false ]; }},
        'codePointAt': { type: 'Number', declaredBy: 'XMLList', parameters: function () { return [ 'Number', false ]; }},
        'indexOf': { type: 'Number', declaredBy: 'XMLList', parameters: function () { return [ 'String', false ,'Number', true ]; }},
        'lastIndexOf': { type: 'Number', declaredBy: 'XMLList', parameters: function () { return [ 'String', false ,'Number', true ]; }},
        'localeCompare': { type: 'Number', declaredBy: 'XMLList', parameters: function () { return [ 'String', false ,'*', true ,'*', true ]; }},
        'match': { type: 'Array', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'search': { type: 'Number', declaredBy: 'XMLList', parameters: function () { return [ '*', false ]; }},
        'slice': { type: 'String', declaredBy: 'XMLList', parameters: function () { return [ 'Number', false ,'*', true ]; }},
        'split': { type: 'Array', declaredBy: 'XMLList', parameters: function () { return [ '*', true ,'*', true ]; }},
        'substr': { type: 'String', declaredBy: 'XMLList', parameters: function () { return [ 'Number', false ,'*', true ]; }},
        'substring': { type: 'String', declaredBy: 'XMLList', parameters: function () { return [ 'Number', false ,'*', true ]; }},
        'toLocaleLowerCase': { type: 'String', declaredBy: 'XMLList'},
        'toLocaleUpperCase': { type: 'String', declaredBy: 'XMLList'},
        'toLowerCase': { type: 'String', declaredBy: 'XMLList'},
        'toUpperCase': { type: 'String', declaredBy: 'XMLList'},
        'trim': { type: 'String', declaredBy: 'XMLList'},
        'toExponential': { type: 'Number', declaredBy: 'XMLList', parameters: function () { return [ '*', true ]; }},
        'toFixed': { type: 'Number', declaredBy: 'XMLList', parameters: function () { return [ 'int', true ]; }},
        'toPrecision': { type: 'Number', declaredBy: 'XMLList', parameters: function () { return [ '*', true ]; }},
        'toXML': { type: 'XML', declaredBy: 'XMLList'},
        'localName': { type: 'String', declaredBy: 'XMLList'}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
XMLList.prototype.ROYALE_COMPILE_FLAGS = 10;

//# sourceMappingURL=./XMLList.js.map
