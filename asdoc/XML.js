/**
 * Generated by Apache Royale Compiler from XML.as
 * XML
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('XML');
/* Royale Dependency List: Namespace,QName,XMLList,org.apache.royale.debugging.assertType,org.apache.royale.language.toAttributeName,XML*/
/* Royale Static Dependency List: org.apache.royale.utils.Language*/

goog.require('org.apache.royale.utils.Language');



/**
 * @royaleignorecoercion XML
 * @constructor
 * @param {*=} xml
 */
XML = function(xml) {
  var self = this;
  xml = typeof xml !== 'undefined' ? xml : null;
  if (xml != null) {
    if (xml instanceof XML) {
      /* jsUnsafeNativeInline code follows */ return xml.copy();
    }
    var /** @type {string} */ xmlStr = "" + xml;
    if (xmlStr.indexOf("<") == -1) {
      if (XML.ignoreWhitespace)
        xmlStr = xmlStr.trim();
      this.setValue(xmlStr);
    } else {
      this.XML_parseXMLStr(xmlStr);
    }
  } else {
    if (!XML._internal) {
      this.setValue('');
    }
  }
  if (!XML._class_initialized) {
    Object.defineProperty(XML.prototype, "0", {"get":function() {
      return this;
    }, "set":function() {
    }, enumerable:true, configurable:true});
    XML._class_initialized = true;
  }
};


/**
 * @private
 * @type {Object}
 */
XML._nameMap = Object.create(null);


/**
 * @private
 * @type {Object}
 */
XML._attrNameMap = Object.create(null);


/**
 * @private
 * @param {string} localName
 * @param {*} prefix
 * @param {string} uri
 * @param {boolean} isAttribute
 * @return {QName}
 */
XML.getQName = function(localName, prefix, uri, isAttribute) {
  localName = localName || "";
  var /** @type {string} */ prefixKey = org.apache.royale.utils.Language.string(prefix == null ? '{$' + prefix + '$}' : prefix);
  uri = uri || '';
  var /** @type {string} */ key = (!prefix && !uri ? localName : localName + ":" + prefixKey + ":" + uri);
  var /** @type {QName} */ qname = (isAttribute ? XML._attrNameMap[key] : XML._nameMap[key]);
  if (!qname) {
    qname = new QName(uri, localName);
    if (prefix != null)
      qname.setPrefix(org.apache.royale.utils.Language.string(prefix));
    if (isAttribute)
      qname.setIsAttribute(true);
    if (isAttribute)
      XML._attrNameMap[key] = qname;
    else
      XML._nameMap[key] = qname;
  }
  return qname;
};


/**
 * Compiler-only method to support multiple 'use namespace' directives
 * this method is not intended for use other than by the compiler
 * If it is never generated in application code,  which only happens
 * with  'use namespace "something"' directives in function execution scope
 * it will be omitted from the js-release build via dead-code elimination
 * (unless dead-code elimination is switched off - it is on by default).
 *
 * @asprivate
 * @royalesuppressexport
 * @royalesuppressclosure
 * @param {Array} namespaces
 * @param {*} name
 * @param {boolean} isAtt
 * @return {QName}
 */
XML.multiQName = function(namespaces, name, isAtt) {
  var /** @type {QName} */ original = name && typeof(name) == 'object' && name['className'] == 'QName' ? name : new QName(name);
  if (isAtt)
    original.setIsAttribute(true);
  var /** @type {Array} */ others = [];
  while (namespaces.length) {
    var /** @type {QName} */ other = new QName(namespaces.shift(), original.localName);
    if (isAtt)
      other.setIsAttribute(true);
    others.push(other);
  }
  var /** @type {Function} */ superCall = original.matches;
  var /** @type {Function} */ matchesOverride = function(qName) {
    var /** @type {boolean} */ match = !!(superCall.call(original, qName));
    if (!match) {
      match = XML.multiMatch(others, qName);
    }
    return match;
  };
  Object.defineProperties(original, {"className":{"get":function() {
    return "MultiName";
  }}, "matches":{'value':matchesOverride}});
  return original;
};


/**
 * @asprivate
 * see multiQName above
 * @private
 * @param {Array} qNames
 * @param {QName} name
 * @return {boolean}
 */
XML.multiMatch = function(qNames, name) {
  var /** @type {number} */ l = (qNames.length) >>> 0;
  var /** @type {boolean} */ match;
  for (var /** @type {number} */ i = 0; i < l; i++) {
    var /** @type {QName} */ check = qNames[i];
    match = check.matches(name);
    if (match)
      break;
  }
  return match;
};


/**
 * Compiler-only method to support swf compatibility for queries,
 * this method is not intended for use other than by the compiler.
 * It may be off-spec, but matches swf implementation behavior.
 * The 'correction' is only applied if the argument passed to the
 * child, descendants, or attributes method of XML or XMLList is strongly typed
 * as a QName.
 * If it is never generated in application code by the compiler,
 * the following code will be omitted from the js-release build via dead-code elimination
 * (unless dead-code elimination is switched off - it is on by default).
 *
 * @asprivate
 * @royalesuppressexport
 * @param {QName} original
 * @param {boolean} isAtt
 * @return {QName}
 */
XML.swfCompatibleQuery = function(original, isAtt) {
  if (!original || !(original.uri))
    return original;
  return XML.multiQName([original.uri], original.localName, isAtt);
};


/**
 * Compiler-only method to support specific namespaced attribute queries.
 * If it is never generated in application code by the compiler,
 * it will be omitted from the js-release build via dead-code elimination
 * (unless dead-code elimination is switched off - it is on by default).
 *
 * @asprivate
 * @royalesuppressexport
 * @param {QName} qname
 * @return {QName}
 */
XML.createAttributeQName = function(qname) {
  if (qname)
    qname.setIsAttribute(true);
  return qname;
};


/**
 * Compiler-only method to support construction with specfied default namespace.
 * This value is applied for each construction call within the applicable scope,
 * because setting default namespace as part of XML class internal state could
 * result in inconsistencies for any departure from the applicable scope
 * (calls to other function scopes or error handling, for example)
 *
 * @asprivate
 * @royalesuppressexport
 * @param {Object} source
 * @param {Object} ns
 * @return {XML}
 */
XML.constructWithDefaultXmlNS = function(source, ns) {
  if (ns) {
    var /** @type {string} */ uri;
    if (typeof(ns) == 'object' && ns['className'] == 'Namespace') {
      uri = org.apache.royale.utils.Language.string(ns.uri);
    } else {
      uri = ns + '';
    }
    var /** @type {XML} */ ret;
    var /** @type {Error} */ err;
    if (ns) {
      try {
        XML._defaultNS = uri;
        ret = new XML(source);
      } catch (e) {
        err = e;
      }
    }
    else
      ret = new XML(source);
    XML._defaultNS = null;
    if (err)
      throw err;
    else
      return ret;
  }
  else
    return new XML(source);
};


/**
 * Compiler-only method to support null-safe, non-strict equality checks between XML-ish types
 * (although both arguments are typed as XML, XMLList is also possible at runtime)
 *
 * @asprivate
 * @royalesuppressexport
 * @param {XML} xml1
 * @param {XML} xml2
 * @return {boolean}
 */
XML.equality = function(xml1, xml2) {
  if (xml1 == null)
    return xml2 == null;
  return xml2 != null ? xml1.equals(xml2) : false;
};


/**
 * Compiler-only method to support null-safe, non-strict equality checks between XML-ish known type
 * and an unknown type. Although the first argument is typed as XML, it handles runtime usage with XMLList type as well
 *
 * @asprivate
 * @royaleignorecoercion XMLList
 * @royaleignorecoercion XML
 * @royalesuppressexport
 * @param {XML} xml1
 * @param {*} other
 * @return {boolean}
 */
XML.mixedEquality = function(xml1, other) {
  if (xml1 instanceof XMLList)
    return XMLList.mixedEquality(xml1, other);
  if (xml1 == null)
    return other == null;
  if (other instanceof XML)
    return xml1.equals(other);
  if (typeof(other) == 'boolean')
    other = ('' + other);
  return xml1 == other;
};


/**
 * @private
 * @const
 * @type {string}
 */
XML.ELEMENT = "e";


/**
 * @private
 * @const
 * @type {string}
 */
XML.ATTRIBUTE = "a";


/**
 * @private
 * @const
 * @type {string}
 */
XML.PROCESSING_INSTRUCTION = "p";


/**
 * @private
 * @const
 * @type {string}
 */
XML.TEXT = "t";


/**
 * @private
 * @const
 * @type {string}
 */
XML.COMMENT = "c";


/**
 * @private
 * @const
 * @type {RegExp}
 */
XML.xmlDecl = /^\s*<\?xml[^?]*\?>/im;


/**
 * Method to free up references to shared QName objects.
 * Probably only worth doing if most or all XML instances can be garbage-collected.
 * @langversion 3.0
 * @productversion Royale 0.9
 * @nocollapse
 */
XML.clearQNameCache = function() {
  XML._nameMap = Object.create(null);
  XML._attrNameMap = Object.create(null);
};


/**
 * @nocollapse
 * @type {boolean}
 */
XML.ignoreComments = true;


/**
 * @nocollapse
 * @type {boolean}
 */
XML.ignoreProcessingInstructions = true;


/**
 * @nocollapse
 * @type {boolean}
 */
XML.ignoreWhitespace = true;


/**
 * @private
 * @type {number}
 */
XML._prettyIndent = 2;


/**
 * @private
 * @type {string}
 */
XML._indentStr = "  ";


/**
 * @private
 * @type {string}
 */
XML.INDENT_CHAR = " ";


/**
 * @nocollapse
 * @type {boolean}
 */
XML.prettyPrinting = true;


/**
 * @nocollapse
 * @type {boolean}
 */
XML.recursiveNotify = false;


/**
 * @private
 * @param {*} value
 * @return {string}
 */
XML.escapeAttributeValue = function(value) {
  if (value === undefined) {
    return "";
  }
  var /** @type {Array} */ arr = String(value).split("");
  var /** @type {number} */ len = (arr.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    switch (arr[i]) {
      case "<":
        arr[i] = "&lt;";
        break;
      case "&":
        if (arr[i + 1] != "#")
          arr[i] = "&amp;";
        break;
      case '"':
        arr[i] = "&quot;";
        break;
      case "\n":
        arr[i] = "&#xA;";
        break;
      case "\r":
        arr[i] = "&#xD;";
        break;
      case "\t":
        arr[i] = "&#x9;";
        break;
      default:
        break;
    }
  }
  return arr.join("");
};


/**
 * @private
 * @param {string} value
 * @return {string}
 */
XML.escapeElementValue = function(value) {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {Array} */ arr = value.split("");
  
/**
 * @const
 * @type {number}
 */
var len = (arr.length) >>> 0;
  for (i = 0; i < len; i++) {
    switch (arr[i]) {
      case "<":
        arr[i] = "&lt;";
        break;
      case ">":
        arr[i] = "&gt;";
        break;
      case "&":
        if (arr[i + 1] != "#")
          arr[i] = "&amp;";
        break;
      default:
        break;
    }
  }
  return arr.join("");
};


/**
 * @private
 * @param {Attr} att
 * @param {XML} parent
 * @return {XML}
 */
XML.insertAttribute = function(att, parent) {
  var /** @type {XML} */ xml = new XML();
  xml.XML__parent = parent;
  xml._name = XML.getQName(att.localName, '', att.namespaceURI, true);
  xml.setValue(att.value);
  parent.addChildInternal(xml);
  return xml;
};


/**
 * @private
 * @param {Element} node
 * @return {Array}
 */
XML.polyFillNodeGetAttributeNames = function(node) {
  var /** @type {number} */ i = 0;
  var /** @type {Array} */ ret = new Array();
  //var /** @type {number} */ i = 0;
  var /** @type {*} */ attrs = node.attributes;
  var /** @type {number} */ len = (node.attributes.length) >> 0;
  for (i = 0; i < len; i++) {
    ret.push(attrs[i].name);
  }
  return ret;
};


/**
 * @private
 * @type {boolean}
 */
XML.hasNodeGetAttributeNames = false;


/**
 * @private
 * @type {boolean}
 */
XML.isInitStatic = false;


/**
 * @private
 * @param {Element} node
 * @param {XML} xml
 */
XML.iterateElement = function(node, xml) {
  var /** @type {number} */ i = 0;
  if (!XML.isInitStatic) {
    XML.hasNodeGetAttributeNames = (node["getAttributeNames"] ? true : false);
    XML.isInitStatic = true;
  }
  //var /** @type {number} */ i = 0;
  var /** @type {Array} */ attrNames = (XML.hasNodeGetAttributeNames ? node["getAttributeNames"]() : XML.polyFillNodeGetAttributeNames(node));
  var /** @type {number} */ len = (attrNames.length) >> 0;
  var /** @type {string} */ localName = node.nodeName;
  var /** @type {string} */ prefix = node.prefix;
  if (prefix && localName.indexOf(prefix + ":") == 0) {
    localName = localName.substr(prefix.length + 1);
  }
  xml._name = XML.getQName(localName, prefix, node.namespaceURI, false);
  var /** @type {Namespace} */ ns;
  for (i = 0; i < len; i++) {
    var /** @type {Attr} */ att = node.getAttributeNode(org.apache.royale.utils.Language.string(attrNames[i]));
    if ((att.name == 'xmlns' || att.prefix == 'xmlns') && att.namespaceURI == 'http://www.w3.org/2000/xmlns/') {
      if (att.prefix) {
        ns = new Namespace(att.localName, att.nodeValue);
      } else {
        ns = new Namespace('', att.nodeValue);
      }
      xml.addNamespace(ns);
    }
    else
      XML.insertAttribute(att, xml);
  }
  for (var /** @type {Node} */ nativeNode = node.firstChild; nativeNode; nativeNode = nativeNode.nextSibling) {
    
/**
 * @const
 * @type {number}
 */
var nodeType = nativeNode.nodeType;
    if ((nodeType == 7 && XML.ignoreProcessingInstructions) || (nodeType == 8 && XML.ignoreComments)) {
      continue;
    }
    var /** @type {XML} */ child = XML.fromNode(nativeNode);
    if (child)
      xml.addChildInternal(child);
  }
};


/**
 * returns an XML object from an existing node without the need to parse the XML.
 * The new XML object is not normalized
 *
 * @royaleignorecoercion Element
 * @private
 * @param {Node} node
 * @return {XML}
 */
XML.fromNode = function(node) {
  var /** @type {XML} */ xml;
  var /** @type {string} */ data;
  switch (node.nodeType) {
    case 1:
      xml = new XML();
      XML.iterateElement(node, xml);
      break;
    case 3:
      if (XML.ignoreWhitespace) {
        data = node.nodeValue.trim();
        if (!data)
          return null;
      } else {
        data = node.nodeValue;
      }
      xml = new XML();
      xml.setValue(data);
      break;
    case 4:
      xml = new XML();
      data = "<![CDATA[" + node.nodeValue + "]]>";
      xml.setValue(data);
      break;
    case 7:
      data = node.nodeValue;
      xml = new XML();
      xml.XML__nodeKind = XML.PROCESSING_INSTRUCTION;
      var /** @type {string} */ localName = node.nodeName;
      if (node.prefix && localName.indexOf(node.prefix + ":") == 0) {
        localName = localName.substr(node.prefix.length + 1);
      }
      xml._name = XML.getQName(localName, null, '', false);
      xml.setValue(data);
      break;
    case 8:
      data = node.nodeValue;
      xml = new XML();
      xml.XML__nodeKind = XML.COMMENT;
      xml.setValue(data);
      break;
    default:
      throw new TypeError("Unknown XML node type!");
      break;
  }
  return xml;
};


/**
 * @private
 * @param {Namespace} ns
 * @param {Array} arr
 * @return {boolean}
 */
XML.namespaceInArray = function(ns, arr) {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {number} */ l = (arr.length) >>> 0;
  for (i = 0; i < l; i++) {
    if (ns.uri == arr[i].uri) {
      if (ns.prefix == arr[i].prefix)
        return true;
    }
  }
  return false;
};


/**
 * [static] Returns an object with the following properties set to the default values: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent, and prettyPrinting.
 * @asreturn
 *
 * @nocollapse
 * @return {Object}
 */
XML.defaultSettings = function() {
  return {ignoreComments:true, ignoreProcessingInstructions:true, ignoreWhitespace:true, prettyIndent:2, prettyPrinting:true, recursiveNotify:false};
};


/**
 * [static] Sets values for the following XML properties: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent, prettyPrinting, and recursiveNotify.
 * @asparam rest
 *
 * @nocollapse
 * @param {Object} value
 */
XML.setSettings = function(value) {
  if (!value)
    return;
  XML.ignoreComments = value.ignoreComments === undefined ? XML.ignoreComments : value.ignoreComments;
  XML.ignoreProcessingInstructions = value.ignoreProcessingInstructions === undefined ? XML.ignoreProcessingInstructions : value.ignoreProcessingInstructions;
  XML.ignoreWhitespace = value.ignoreWhitespace === undefined ? XML.ignoreWhitespace : value.ignoreWhitespace;
  XML.prettyIndent = value.prettyIndent === undefined ? XML.prettyIndent : value.prettyIndent;
  XML.prettyPrinting = value.prettyPrinting === undefined ? XML.prettyPrinting : value.prettyPrinting;
  XML.recursiveNotify = value.recursiveNotify === undefined ? XML.recursiveNotify : value.recursiveNotify;
};


/**
 * [static] Retrieves the following properties: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent, prettyPrinting, and recursiveNotify.
 *
 * @asreturn
 *
 * @nocollapse
 * @return {Object}
 */
XML.settings = function() {
  return {ignoreComments:XML.ignoreComments, ignoreProcessingInstructions:XML.ignoreProcessingInstructions, ignoreWhitespace:XML.ignoreWhitespace, prettyIndent:XML.prettyIndent, prettyPrinting:XML.prettyPrinting, recursiveNotify:XML.recursiveNotify};
};


/**
 *  mimics the top-level XML function
 *  @royaleignorecoercion XMLList
 *
 *  @royalesuppressexport
 * @param {*} xml
 * @param {*} defaultNS
 * @return {XML}
 */
XML.conversion = function(xml, defaultNS) {
  if (xml == null) {
    return new XML();
  } else if (xml.ROYALE_CLASS_INFO != null) {
    var /** @type {string} */ className = org.apache.royale.utils.Language.string(xml.ROYALE_CLASS_INFO.names[0].name);
    switch (className) {
      case "XML":
        return xml;
      case "XMLList":
        var /** @type {XMLList} */ xmlList = xml;
        if (xmlList.length() == 1)
          return xmlList[0];
        return null;
    }
  }
  if (defaultNS !== undefined) {
    return XML.constructWithDefaultXmlNS(xml, defaultNS);
  }
  else
    return new XML(xml);
};


/**
 * @private
 * @type {string}
 */
XML._defaultNS;


/**
 * @private
 * @type {boolean}
 */
XML._internal;


/**
 * @private
 * @type {boolean}
 */
XML._class_initialized = false;


/**
 * @private
 * @const
 * @type {RegExp}
 */
XML.xmlRegEx = /&(?![\w]+;)/g;


/**
 * @private
 * @const
 * @type {RegExp}
 */
XML.isWhitespace = /^\s+$/;


/**
 * @private
 * @type {DOMParser}
 */
XML.parser;


/**
 * @private
 * @type {string}
 */
XML.errorNS;


/**
 *
 * @royaleignorecoercion Element
 * @private
 * @param {string} xml
 */
XML.prototype.XML_parseXMLStr = function(xml) {
  xml = xml.replace(XML.xmlRegEx, "&amp;");
  if (!XML.parser)
    XML.parser = new DOMParser();
  var /** @type {Document} */ doc;
  if (XML.errorNS == null) {
    try {
      XML.errorNS = XML.parser.parseFromString('<', 'application/xml').getElementsByTagName("parsererror")[0].namespaceURI;
    } catch (err) {
      XML.errorNS = "na";
    }
  }
  var /** @type {string} */ decl = org.apache.royale.utils.Language.string(XML.xmlDecl.exec(xml));
  if (decl)
    xml = xml.replace(decl, '');
  if (XML.ignoreWhitespace)
    xml = xml.trim();
  if (XML._defaultNS)
    xml = '<parseRoot xmlns="' + XML._defaultNS + '">' + xml + '</parseRoot>';
  else
    xml = '<parseRoot>' + xml + '</parseRoot>';
  try {
    doc = XML.parser.parseFromString(xml, "application/xml");
  } catch (err) {
    throw err;
  }
  var /** @type {NodeList} */ errorNodes = doc.getElementsByTagNameNS(org.apache.royale.utils.Language.string(XML.errorNS), 'parsererror');
  if (errorNodes.length > 0)
    throw new Error(errorNodes[0].innerHTML);
  doc = doc.childNodes[0];
  var /** @type {number} */ childCount = (doc.childNodes.length) >>> 0;
  var /** @type {boolean} */ foundRoot;
  var /** @type {number} */ foundCount = 0;
  for (var /** @type {number} */ i = 0; i < childCount; i++) {
    var /** @type {Node} */ node = doc.childNodes[i];
    if (node.nodeType == 1) {
      if (foundRoot) {
        foundCount++;
        break;
      }
      foundRoot = true;
      foundCount = 1;
      if (foundCount != 0) {
        this.resetNodeKind();
      }
      this._name = XML.getQName(node.localName, node.prefix, node.namespaceURI, false);
      XML._internal = true;
      XML.iterateElement(node, this);
      XML._internal = false;
    } else {
      if (foundRoot)
        continue;
      if (node.nodeType == 7) {
        if (XML.ignoreProcessingInstructions) {
          if (!foundCount) {
            delete this._name;
            this.setValue('');
          }
        } else {
          this.XML__nodeKind = XML.PROCESSING_INSTRUCTION;
          this.setName(node.nodeName);
          this.setValue(node.nodeValue);
          foundCount++;
        }
      } else if (node.nodeType == 4) {
        if (!foundCount) {
          delete this._name;
          this.setValue('<![CDATA[' + node.nodeValue + ']]>');
        }
        foundCount++;
      } else if (node.nodeType == 8) {
        delete this._name;
        if (XML.ignoreComments) {
          if (!foundCount) {
            this.setValue('');
          }
        } else {
          if (!foundCount) {
            this.XML__nodeKind = XML.COMMENT;
            this.setValue(node.nodeValue);
          }
          foundCount++;
        }
      } else if (node.nodeType == 3) {
        var /** @type {boolean} */ whiteSpace = !!(XML.isWhitespace.test(node.nodeValue));
        if (!whiteSpace || !XML.ignoreWhitespace) {
          if (!foundCount) {
            delete this._name;
            this.setValue(node.nodeValue);
          }
          foundCount++;
        } else {
        }
      }
    }
  }
  if (foundCount > 1)
    throw new TypeError('Error #1088: The markup in the document following the root element must be well-formed.');
};


/**
 * @protected
 */
XML.prototype.resetNodeKind = function() {
  delete this.XML__nodeKind;
  delete this._value;
  delete this._name;
};


/**
 * @protected
 * @type {Array}
 */
XML.prototype._children;


/**
 * @protected
 * @type {Array}
 */
XML.prototype._attributes;


/**
 * @private
 * @type {XML}
 */
XML.prototype.XML__parent;


/**
 * @protected
 * @type {string}
 */
XML.prototype._value;


/**
 * @protected
 * @type {Array}
 */
XML.prototype._namespaces;


/**
 * @private
 * @return {Array}
 */
XML.prototype.XML_getNamespaces = function() {
  if (!this._namespaces)
    this._namespaces = [];
  return this._namespaces;
};


/**
 * @asprivate
 *
 * Similar to appendChild, but accepts all XML types (text, comment, processing-instruction, attribute, or element)
 *
 *
 * @param {XML} child
 */
XML.prototype.addChild = function(child) {
  if (!child)
    return;
  this.addChildInternal(child);
  this.normalize();
};


/**
 * @protected
 * @param {XML} child
 */
XML.prototype.addChildInternal = function(child) {
  org.apache.royale.debugging.assertType(child, XML, "Type must be XML");
  child.setParent(this);
  if (child.getNodeRef() == XML.ATTRIBUTE) {
    this.XML_getAttributes().push(child);
    this.xml$_notify("attributeAdded", this, child.name().toString(), child.getValue());
  } else {
    this.XML_getChildren().push(child);
    this.xml$_notify("nodeAdded", this, child, null);
  }
};


/**
 * @private
 * @return {Array}
 */
XML.prototype.XML_getChildren = function() {
  if (!this._children)
    this._children = [];
  return this._children;
};


/**
 * @private
 * @return {Array}
 */
XML.prototype.XML_getAttributes = function() {
  if (!this._attributes)
    this._attributes = [];
  return this._attributes;
};


/**
 * Adds a namespace to the set of in-scope namespaces for the XML object.
 *
 * @asparam ns
 * @asreturn
 *
 *
 * @royaleignorecoercion QName
 * @param {Namespace} ns
 * @return {XML}
 */
XML.prototype.addNamespace = function(ns) {
  var /** @type {XML} */ ret = this.addNamespaceInternal(ns);
  this.xml$_notify("namespaceAdded", this, ns, null);
  return ret;
};


/**
 * @param {Namespace} ns
 * @return {XML}
 */
XML.prototype.addNamespaceInternal = function(ns) {
  var /** @type {number} */ i = 0;
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.TEXT || kind == XML.COMMENT || kind == XML.PROCESSING_INSTRUCTION || kind == XML.ATTRIBUTE)
    return this;
  if (ns.prefix === undefined)
    return this;
  if (ns.prefix == "" && this.name().uri == "")
    return this;
  var /** @type {Namespace} */ match = null;
  //var /** @type {number} */ i = 0;
  var /** @type {Array} */ nSpaces = this.XML_getNamespaces();
  var /** @type {number} */ len = (nSpaces.length) >> 0;
  for (i = (len - 1) >> 0; i > 0; i--) {
    if (nSpaces[i].prefix == ns.prefix) {
      match = nSpaces[i];
      break;
    }
  }
  if (match && match.uri != ns.uri) {
    nSpaces.splice(i, 1);
    len--;
  }
  nSpaces[len] = ns;
  if (ns.prefix == this.name().prefix) {
    this._name = XML.getQName(org.apache.royale.utils.Language.string(this._name.localName), undefined, org.apache.royale.utils.Language.string(this._name.uri), false);
  }
  len = this.attributeLength();
  for (i = 0; i < len; i++) {
    var /** @type {XML} */ att = this._attributes[i];
    if (att.name().prefix == ns.prefix) {
      att._name = XML.getQName(org.apache.royale.utils.Language.as(att._name, QName, true).localName, null, org.apache.royale.utils.Language.as(att._name, QName, true).uri, true);
    }
  }
  return this;
};


/**
 * Appends the given child to the end of the XML object's properties.
 *
 * @asparam child
 * @asreturn
 *
 * @royaleignorecoercion XML
 *
 * @param {*} child
 * @return {XML}
 */
XML.prototype.appendChild = function(child) {
  var /** @type {string} */ childType = typeof(child);
  var /** @type {boolean} */ isTextSet = false;
  if (childType != "object") {
    
/**
 * @const
 * @type {number}
 */
var last = (this.childrenLength()) >>> 0;
    
/**
 * @const
 * @type {XML}
 */
var lastChild = last ? this._children[last - 1] : null;
    if (lastChild && lastChild.getNodeRef() == XML.ELEMENT) {
      
/**
 * @const
 * @type {XML}
 */
var wrapper = new XML();
      wrapper.resetNodeKind();
      child = new XML(child.toString());
      wrapper._name = lastChild._name;
      child.setParent(wrapper);
      wrapper.XML_getChildren().push(child);
      child = wrapper;
    } else {
      child = this.XML_xmlFromStringable(child);
    }
    isTextSet = true;
  }
  if (org.apache.royale.utils.Language.is(child, XML) && child.getNodeRef() == XML.ATTRIBUTE) {
    var /** @type {XML} */ xml = new XML();
    xml.setValue(child.toString());
    child = xml;
    isTextSet = true;
  }
  this.XML_appendChildInternal(child, isTextSet);
  return this;
};


/**
 *
 * @royaleignorecoercion XML
 * @private
 * @param {*} child
 * @param {boolean=} isTextSet
 */
XML.prototype.XML_appendChildInternal = function(child, isTextSet) {
  isTextSet = typeof isTextSet !== 'undefined' ? isTextSet : false;
  var /** @type {number} */ alreadyPresent = 0;
  var /** @type {number} */ i = 0;
  var /** @type {string} */ kind;
  //var /** @type {number} */ alreadyPresent = 0;
  var /** @type {Array} */ children = this.XML_getChildren();
  var /** @type {boolean} */ isAttribute;
  if (org.apache.royale.utils.Language.is(child, XMLList)) {
    var /** @type {number} */ len = (child.length()) >> 0;
    var /** @type {number} */ oldChildrenLength = this.childrenLength();
    //var /** @type {number} */ i = 0;
    for (i = 0; i < len; i++) {
      var /** @type {XML} */ childItem = child[i];
      isAttribute = false;
      kind = childItem.getNodeRef();
      if (kind == XML.ATTRIBUTE) {
        var /** @type {string} */ name = childItem.localName();
        var /** @type {string} */ content = '<' + name + '>' + childItem.toString() + '</' + name + '>';
        childItem = new XML(content);
        isAttribute = true;
      } else {
        alreadyPresent = (children.indexOf(childItem)) >> 0;
        if (alreadyPresent != -1)
          children.splice(alreadyPresent, 1);
      }
      childItem.setParent(this, true);
      children.push(childItem);
    }
    if (this.XML__notification || (XML.recursiveNotify && this.XML__parent)) {
      for (i = 0; i < len; i++) {
        var /** @type {XML} */ originalChildItem = child[i];
        isAttribute = false;
        kind = originalChildItem.getNodeRef();
        if (kind == XML.ATTRIBUTE) {
          isAttribute = true;
        }
        var /** @type {XML} */ finalChildItem = children[oldChildrenLength + i];
        if (isAttribute)
          this.xml$_notify("attributeAdded", this, finalChildItem.name().toString(), finalChildItem.getValue());
        else
          this.xml$_notify("nodeAdded", this, finalChildItem, null);
      }
    }
  } else {
    org.apache.royale.debugging.assertType(child, XML, "Type must be XML");
    isAttribute = false;
    kind = org.apache.royale.utils.Language.string(child.getNodeRef());
    if (kind == XML.ATTRIBUTE) {
      child = new XML(child.toString());
      isAttribute = true;
    } else {
      alreadyPresent = (children.indexOf(child)) >> 0;
      if (alreadyPresent != -1)
        children.splice(alreadyPresent, 1);
    }
    child.setParent(this);
    children.push(child);
    if (isAttribute) {
      if (isTextSet) {
        this.xml$_notify("textSet", child, child.getValue(), null);
      }
      this.xml$_notify("attributeAdded", this, child.name().toString(), child.getValue());
    } else if (isTextSet) {
      var /** @type {XML} */ childValueNode = (child._children ? child._children[0] : child);
      this.xml$_notify("textSet", childValueNode, childValueNode.getValue(), null);
      this.xml$_notify("nodeAdded", childValueNode.XML__parent, childValueNode, null);
    }
    else
      this.xml$_notify("nodeAdded", this, child, null);
  }
};


/**
 * Returns the XML value of the attribute that has the name matching the attributeName parameter.
 *
 * @asparam attributeName
 * @asreturn
 *
 * @param {*} attributeName
 * @return {XMLList}
 */
XML.prototype.attribute = function(attributeName) {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  if (attributeName == "*")
    return this.attributes();
  attributeName = org.apache.royale.language.toAttributeName(attributeName);
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.attributeLength();
  for (i = 0; i < len; i++) {
    if (attributeName.matches(this._attributes[i].name()))
      list.append(this._attributes[i]);
  }
  list.targetObject = this;
  list.targetProperty = attributeName;
  return list;
};


/**
 * Returns a list of attribute values for the given XML object.
 *
 * @asreturn
 *
 * @return {XMLList}
 */
XML.prototype.attributes = function() {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.attributeLength();
  for (i = 0; i < len; i++)
    list.append(this._attributes[i]);
  list.targetObject = this;
  return list;
};


/**
 * Lists the children of an XML object.
 *
 * @asparam propertyName
 * @asreturn
 *
 * @royaleignorecoercion XML
 * @param {Object} propertyName
 * @return {XMLList}
 */
XML.prototype.child = function(propertyName) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  var /** @type {XMLList} */ list = new XMLList();
  if (parseInt(propertyName, 10).toString() == propertyName) {
    if (propertyName != "0")
      return null;
    list.append(this);
    list.targetObject = this;
    return list;
  }
  if (propertyName && propertyName['className'] != 'MultiName')
    propertyName = this.XML_toXMLName(propertyName);
  if (propertyName.isAttribute) {
    len = this.attributeLength();
    for (i = 0; i < len; i++) {
      if (propertyName.matches(this._attributes[i].name()))
        list.append(this._attributes[i]);
    }
  } else {
    len = this.childrenLength();
    var /** @type {boolean} */ all = propertyName.localName == "*" && propertyName.uri === '';
    for (i = 0; i < len; i++) {
      var /** @type {XML} */ child = this._children[i];
      if (all || propertyName.matches(child.name()))
        list.append(child);
    }
  }
  list.targetObject = this;
  list.targetProperty = propertyName;
  return list;
};


/**
 * Identifies the zero-indexed position of this XML object within the context of its parent.
 *
 * @asreturn
 *
 * @return {number}
 */
XML.prototype.childIndex = function() {
  if (!this.XML__parent)
    return -1;
  return (this.XML__parent.getIndexOf(this)) >> 0;
};


/**
 * Lists the children of the XML object in the sequence in which they appear.
 *
 * @asreturn
 *
 * @return {XMLList}
 */
XML.prototype.children = function() {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    list.append(this._children[i]);
  }
  list.targetObject = this;
  return list;
};


/**
 * Lists the properties of the XML object that contain XML comments.
 *
 * @asreturn
 *
 * @royaleignorecoercion XML
 * @return {XMLList}
 */
XML.prototype.comments = function() {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].getNodeRef() == XML.COMMENT)
      list.append(this._children[i]);
  }
  list.targetObject = this;
  return list;
};


/**
 *
 * @asparam list
 * @asreturn an XMLList representing the concatenation of this XML instance and either another XML instance or an XMLList
 *
 * @royaleignorecoercion XMLList
 * @royaleignorecoercion XML
 * @param {*} list
 * @return {XMLList}
 */
XML.prototype.concat = function(list) {
  if (org.apache.royale.utils.Language.is(list, XML)) {
    var /** @type {XMLList} */ newList = new XMLList();
    newList.append(list);
    list = newList;
  }
  if (!org.apache.royale.utils.Language.is(list, XMLList))
    throw new TypeError("invalid type");
  var /** @type {XMLList} */ retVal = new XMLList();
  retVal.append(this);
  var /** @type {XML} */ item;
  var foreachiter0_target = list;
  for (var foreachiter0 in foreachiter0_target.elementNames()) 
  {
  item = foreachiter0_target[foreachiter0];
  
    retVal.append(item);}
  
  return retVal;
};


/**
 * Compares the XML object against the given value parameter.
 *
 * @asparam value
 * @asreturn
 *
 * @param {*} value
 * @return {boolean}
 */
XML.prototype.contains = function(value) {
  if (org.apache.royale.utils.Language.is(value, XML) || org.apache.royale.utils.Language.is(value, XMLList))
    return this.equals(value);
  return value == this;
};


/**
 * Returns a copy of the given XML object.
 *
 * @asreturn
 *
 * @return {XML}
 */
XML.prototype.copy = function() {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {XML} */ xml = new XML();
  xml.resetNodeKind();
  xml.setNodeKind(this.getNodeKindInternal());
  xml._name = this._name;
  xml.setValue(org.apache.royale.utils.Language.string(this._value));
  //var /** @type {number} */ len = 0;
  len = this.namespaceLength();
  for (i = 0; i < len; i++) {
    xml.addNamespace(new Namespace(this._namespaces[i]));
  }
  len = this.attributeLength();
  for (i = 0; i < len; i++)
    xml.addChildInternal(this._attributes[i].copy());
  len = this.childrenLength();
  for (i = 0; i < len; i++)
    xml.addChildInternal(this._children[i].copy());
  return xml;
};


/**
 * @royaleignorecoercion XML
 * @private
 * @param {number} idx
 */
XML.prototype.XML_deleteChildAt = function(idx) {
  var /** @type {XML} */ child = this._children[idx];
  child.XML__parent = null;
  this._children.splice(idx, 1);
};


/**
 * Returns all descendants (children, grandchildren, great-grandchildren, and so on) of the XML object that have the given name parameter.
 *
 * @asparam name
 * @asreturn
 *
 * @royaleignorecoercion XML
 *
 * @param {Object=} name
 * @return {XMLList}
 */
XML.prototype.descendants = function(name) {
  name = typeof name !== 'undefined' ? name : "*";
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  if (!name)
    name = "*";
  var /** @type {Array} */ descendents = this.XML_getDescendentArray(this, this.XML_toXMLName(name), []);
  
  return XMLList.fromArray(descendents);
};


/**
 * @private
 * @param {XML} current
 * @param {QName} name
 * @param {Array} arr
 * @return {Array}
 */
XML.prototype.XML_getDescendentArray = function(current, name, arr) {
  if (name.isAttribute && current._attributes) {
    var foreachiter1_target = current._attributes;
    for (var foreachiter1 in foreachiter1_target) 
    {
    var attr = foreachiter1_target[foreachiter1];
    {
      if (name.matches(attr.name()))
        arr.push(attr);
    }}
    
  }
  if (current._children) {
    var foreachiter2_target = current._children;
    for (var foreachiter2 in foreachiter2_target) 
    {
    var child = foreachiter2_target[foreachiter2];
    {
      if (name.matches(child.name()))
        arr.push(child);
      if (child.getNodeRef() == XML.ELEMENT) {
        this.XML_getDescendentArray(child, name, arr);
      }
    }}
    
  }
  return arr;
};


/**
 * Lists the elements of an XML object. (handles E4X dot notation)
 *
 * @asparam name
 * @asreturn
 *
 * @royaleignorecoercion XML
 * @param {Object=} name
 * @return {XMLList}
 */
XML.prototype.elements = function(name) {
  name = typeof name !== 'undefined' ? name : "*";
  var /** @type {number} */ i = 0;
  if (!name)
    name = "*";
  var /** @type {boolean} */ all = (name == "*");
  name = this.XML_toXMLName(name);
  //var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].getNodeRef() == XML.ELEMENT && (all || name.matches(this._children[i].name())))
      list.append(this._children[i]);
  }
  list.targetObject = this;
  list.targetProperty = name;
  return list;
};


/**
 * for each should work on XML too
 * @asprivate
 * @return {Array}
 */
XML.prototype.elementNames = function() {
  return [0];
};


/**
 *
 * @asprivate
 * @royaleignorecoercion XML
 * @param {*} xml
 * @return {boolean}
 */
XML.prototype.equals = function(xml) {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  if (xml === this)
    return true;
  if (xml instanceof XMLList) {
    if (org.apache.royale.utils.Language.as(xml, XMLList).length() != 1)
      return false;
    xml = org.apache.royale.utils.Language.as(xml, XMLList)[0];
  }
  else if (!(xml instanceof XML))
    return false;
  var /** @type {XML} */ typedXML = xml;
  if (typedXML.getNodeRef() != this.getNodeRef())
    return false;
  if (this._name) {
    if (!typedXML._name || !this._name.equals(typedXML._name))
      return false;
  } else if (typedXML._name) {
    return false;
  }
  var /** @type {Array} */ selfAttrs = this.getAttributeArray();
  var /** @type {Array} */ xmlAttrs = typedXML.getAttributeArray();
  if (selfAttrs.length != xmlAttrs.length)
    return false;
  var /** @type {Array} */ selfChldrn = this.getChildrenArray();
  var /** @type {Array} */ xmlChildren = typedXML.getChildrenArray();
  if (selfChldrn.length != xmlChildren.length)
    return false;
  if (this.getValue() != typedXML.getValue())
    return false;
  for (i = 0; i < selfAttrs.length; i++) {
    if (!typedXML.hasAttribute(selfAttrs[i]))
      return false;
  }
  for (i = 0; i < selfChldrn.length; i++) {
    if (!selfChldrn[i].equals(xmlChildren[i]))
      return false;
  }
  return true;
};


/**
 * @param {*} nameOrXML
 * @param {string=} value
 * @return {boolean}
 */
XML.prototype.hasAttribute = function(nameOrXML, value) {
  value = typeof value !== 'undefined' ? value : null;
  var /** @type {number} */ i = 0;
  if (!this._attributes)
    return false;
  var /** @type {QName} */ name;
  if (org.apache.royale.utils.Language.is(nameOrXML, XML)) {
    name = nameOrXML.name();
    value = org.apache.royale.utils.Language.string(nameOrXML.getValue());
  } else {
    name = new QName(nameOrXML);
    name.setIsAttribute(true);
  }
  //var /** @type {number} */ i = 0;
  var /** @type {number} */ len = this.attributeLength();
  for (i = 0; i < len; i++) {
    if (name.matches(this._attributes[i].name())) {
      if (!value)
        return true;
      return value == this._attributes[i].getValue();
    }
  }
  return false;
};


/**
 * @private
 * @param {Array} namespaces
 * @return {Array}
 */
XML.prototype.XML_getAncestorNamespaces = function(namespaces) {
  var /** @type {number} */ nsIdx = 0;
  var /** @type {number} */ pIdx = 0;
  namespaces = namespaces.slice();
  //var /** @type {number} */ nsIdx = 0;
  //var /** @type {number} */ pIdx = 0;
  if (this.XML__parent) {
    var /** @type {Array} */ parentNS = this.XML__parent.inScopeNamespaces();
    var /** @type {number} */ len = (parentNS.length) >> 0;
    for (pIdx = 0; pIdx < len; pIdx++) {
      var /** @type {Namespace} */ curNS = parentNS[pIdx];
      var /** @type {boolean} */ doInsert = true;
      for (nsIdx = 0; nsIdx < namespaces.length; nsIdx++) {
        if (curNS.uri == namespaces[nsIdx].uri && curNS.prefix == namespaces[nsIdx].prefix) {
          doInsert = false;
          break;
        }
      }
      if (doInsert)
        namespaces.push(curNS);
    }
    namespaces = this.XML__parent.getAncestorNamespaces(namespaces);
  }
  return namespaces;
};


/**
 * This method is public to enable code optimizations for getting attributes
 * @return {Array}
 */
XML.prototype.getAttributeArray = function() {
  return this._attributes ? this._attributes : [];
};


/**
 * This method is public to enable code optimizations for getting children
 * @return {Array}
 */
XML.prototype.getChildrenArray = function() {
  return this._children ? this._children : [];
};


/**
 * @param {XML} elem
 * @return {number}
 */
XML.prototype.getIndexOf = function(elem) {
  return (this._children ? this._children.indexOf(elem) : -1) >> 0;
};


/**
 * @protected
 * @return {number}
 */
XML.prototype.childrenLength = function() {
  return (this._children ? this._children.length : 0) >> 0;
};


/**
 * @protected
 * @return {number}
 */
XML.prototype.attributeLength = function() {
  return (this._attributes ? this._attributes.length : 0) >> 0;
};


/**
 * @protected
 * @return {number}
 */
XML.prototype.namespaceLength = function() {
  return (this._namespaces ? this._namespaces.length : 0) >> 0;
};


/**
 * @private
 * @param {string} prefix
 * @return {string}
 */
XML.prototype.XML_getURI = function(prefix) {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {Array} */ namespaces = this.inScopeNamespaces();
  for (i = 0; i < namespaces.length; i++) {
    if (namespaces[i].prefix == prefix)
      return org.apache.royale.utils.Language.string(namespaces[i].uri);
  }
  return "";
};


/**
 * @return {string}
 */
XML.prototype.getValue = function() {
  return org.apache.royale.utils.Language.string(this._value ? this._value : "");
};


/**
 * @param {*} obj
 * @return {boolean}
 */
XML.prototype.hasAncestor = function(obj) {
  if (!obj)
    return false;
  var /** @type {XML} */ parent = this.parent();
  while (parent) {
    if (obj == parent)
      return true;
    parent = parent.parent();
  }
  return false;
};


/**
 * Checks to see whether the XML object contains complex content.
 *
 * @asreturn true if this XML instance contains complex content
 *
 * @royaleignorecoercion XML
 * @return {boolean}
 */
XML.prototype.hasComplexContent = function() {
  var /** @type {number} */ i = 0;
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.ATTRIBUTE || kind == XML.COMMENT || kind == XML.PROCESSING_INSTRUCTION || kind == XML.TEXT)
    return false;
  //var /** @type {number} */ i = 0;
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].getNodeRef() == XML.ELEMENT)
      return true;
  }
  return false;
};


/**
 *
 * @royaleignorecoercion XML
 * @override
 */
XML.prototype.hasOwnProperty = function(p) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  if (parseInt(p, 10).toString() == p)
    return p == "0";
  var /** @type {QName} */ name = this.XML_toXMLName(p);
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  if (name.isAttribute) {
    len = this.attributeLength();
    for (i = 0; i < len; i++) {
      if (name.matches(this._attributes[i].name()))
        return true;
    }
  } else {
    len = this.childrenLength();
    for (i = 0; i < len; i++) {
      if (this._children[i].getNodeRef() != XML.ELEMENT)
        continue;
      if (this._children[i].name().matches(name))
        return true;
    }
  }
  return false;
};


/**
 * Checks to see whether the XML object contains simple content.
 *
 * @asreturn
 *
 * @royaleignorecoercion XML
 * @return {boolean}
 */
XML.prototype.hasSimpleContent = function() {
  var /** @type {number} */ i = 0;
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.COMMENT || kind == XML.PROCESSING_INSTRUCTION)
    return false;
  //var /** @type {number} */ i = 0;
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].getNodeRef() == XML.ELEMENT)
      return false;
  }
  return true;
};


/**
 * Lists the namespaces for the XML object, based on the object's parent.
 *
 * @asreturn
 *
 * @return {Array}
 */
XML.prototype.inScopeNamespaces = function() {
  var /** @type {XML} */ y = this;
  var /** @type {Array} */ inScopeNS = [];
  var /** @type {number} */ i = 0;
  var /** @type {Object} */ prefixCheck = {};
  while (y != null) {
    var /** @type {Array} */ searchNS = y._namespaces;
    if (searchNS) {
      var foreachiter3_target = searchNS;
      for (var foreachiter3 in foreachiter3_target) 
      {
      var ns = foreachiter3_target[foreachiter3];
      {
        if (!prefixCheck[ns.prefix]) {
          inScopeNS[i++] = ns;
          prefixCheck[ns.prefix] = true;
        }
      }}
      
    }
    y = y.parent();
  }
  return inScopeNS;
};


/**
 * @private
 * @param {XML} child
 * @param {number} idx
 */
XML.prototype.XML_insertChildAt = function(child, idx) {
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.TEXT || kind == XML.COMMENT || kind == XML.PROCESSING_INSTRUCTION || kind == XML.ATTRIBUTE)
    return;
  if (!child)
    return;
  var /** @type {XML} */ parent = child.parent();
  if (parent)
    parent.removeChild(child);
  child.setParent(this);
  this.XML_getChildren().splice(idx, 0, child);
  this.xml$_notify("nodeAdded", this, child, null);
};


/**
 * Inserts the given child2 parameter after the child1 parameter in this XML object and returns the resulting object.
 *
 * @asparam child1
 * @asparam child2
 * @asreturn
 *
 * @param {XML} child1
 * @param {XML} child2
 * @return {XML}
 */
XML.prototype.insertChildAfter = function(child1, child2) {
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.TEXT || kind == XML.COMMENT || kind == XML.PROCESSING_INSTRUCTION || kind == XML.ATTRIBUTE)
    return null;
  if (!child1) {
    this.XML_insertChildAt(child2, 0);
    return child2;
  }
  var /** @type {number} */ idx = this.getIndexOf(child1);
  if (idx >= 0) {
    this.XML_insertChildAt(child2, (idx + 1) >> 0);
  }
  return child2;
};


/**
 * Inserts the given child2 parameter before the child1 parameter in this XML object and returns the resulting object.
 *
 * @asparam child1
 * @asparam child2
 * @asreturn
 *
 * @param {XML} child1
 * @param {XML} child2
 * @return {XML}
 */
XML.prototype.insertChildBefore = function(child1, child2) {
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.TEXT || kind == XML.COMMENT || kind == XML.PROCESSING_INSTRUCTION || kind == XML.ATTRIBUTE)
    return null;
  if (!child1) {
    var /** @type {number} */ len = this.childrenLength();
    this.XML_insertChildAt(child2, len);
    return child2;
  }
  var /** @type {number} */ idx = this.getIndexOf(child1);
  if (idx >= 0) {
    this.XML_insertChildAt(child2, idx);
  }
  return child2;
};


/**
 * For XML objects, this method always returns the integer 1.
 *
 * @asreturn
 *
 * @return {number}
 */
XML.prototype.length = function() {
  return 1;
};


/**
 * Gives the local name portion of the qualified name of the XML object.
 *
 * @asreturn
 *
 * @return {string}
 */
XML.prototype.localName = function() {
  return org.apache.royale.utils.Language.string(this._name ? this._name.localName : null);
};


/**
 * @protected
 * @type {QName}
 */
XML.prototype._name;


/**
 * Gives the qualified name for the XML object.
 *
 * @asreturn
 *
 * @return {QName}
 */
XML.prototype.name = function() {
  return this._name ? this._name : null;
};


/**
 * If no parameter is provided, gives the namespace associated with the qualified name of this XML object.
 *
 * @asparam prefix
 * @asreturn
 *
 * @param {string=} prefix
 * @return {*}
 */
XML.prototype.namespace = function(prefix) {
  prefix = typeof prefix !== 'undefined' ? prefix : null;
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.TEXT || kind == XML.COMMENT || kind == XML.PROCESSING_INSTRUCTION)
    return null;
  var /** @type {Array} */ inScopeNS = this.inScopeNamespaces();
  if (prefix == null)
    return this.name().getNamespace(inScopeNS);
  var /** @type {number} */ len = (inScopeNS.length) >> 0;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    if (inScopeNS[i].prefix == prefix)
      return inScopeNS[i];
  }
  return null;
};


/**
 * Lists namespace declarations associated with the XML object in the context of its parent.
 *
 * @asreturn
 *
 * @return {Array}
 */
XML.prototype.namespaceDeclarations = function() {
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.TEXT || kind == XML.COMMENT || kind == XML.PROCESSING_INSTRUCTION || kind == XML.ATTRIBUTE)
    return [];
  var /** @type {Array} */ nspaces = this._namespaces;
  if (!nspaces || !nspaces.length)
    return [];
  var /** @type {Array} */ ancestors = this.XML__parent ? this.XML__parent.inScopeNamespaces() : [];
  if (!ancestors.length) {
    return nspaces.slice();
  }
  var /** @type {Array} */ declaredNS = [];
  var /** @type {boolean} */ match;
  var foreachiter4_target = nspaces;
  for (var foreachiter4 in foreachiter4_target) 
  {
  var ns = foreachiter4_target[foreachiter4];
  {
    match = false;
    var foreachiter5_target = ancestors;
    for (var foreachiter5 in foreachiter5_target) 
    {
    var ns2 = foreachiter5_target[foreachiter5];
    {
      if (ns.prefix == ns.prefix && ns.uri == ns2.uri) {
        match = true;
        break;
      }
    }}
    
    if (!match) {
      declaredNS.push(ns);
    }
  }}
  
  return declaredNS;
};


/**
 * @private
 * @type {string}
 */
XML.prototype.XML__nodeKind;


/**
 * @protected
 * @return {string}
 */
XML.prototype.getNodeKindInternal = function() {
  return org.apache.royale.utils.Language.string(XML.kindNameLookup[this.getNodeRef()]);
};


/**
 * @protected
 * @return {string}
 */
XML.prototype.getNodeRef = function() {
  if (this.XML__nodeKind)
    return org.apache.royale.utils.Language.string(this.XML__nodeKind);
  if (!this._name)
    return org.apache.royale.utils.Language.string(XML.TEXT);
  if (this._name.isAttribute) {
    return org.apache.royale.utils.Language.string(XML.ATTRIBUTE);
  }
  return org.apache.royale.utils.Language.string(XML.ELEMENT);
};


/**
 * @private
 * @const
 * @type {Object}
 */
XML.kindNameLookup = {"e":"element", "a":"attribute", "p":"processing-instruction", "t":"text", "c":"comment"};


/**
 * @private
 * @const
 * @type {Object}
 */
XML.kindRefLookup = {"element":"e", "attribute":"a", "processing-instruction":"p", "text":"t", "comment":"c"};


/**
 * Specifies the type of node: text, comment, processing-instruction, attribute, or element.
 * @asreturn
 *
 * @return {string}
 */
XML.prototype.nodeKind = function() {
  return this.getNodeKindInternal();
};


/**
 * For the XML object and all descendant XML objects, merges adjacent text nodes and eliminates empty text nodes.
 *
 * @asreturn
 *
 * @return {XML}
 */
XML.prototype.normalize = function() {
  var /** @type {number} */ len = (this.childrenLength() - 1) >> 0;
  var /** @type {XML} */ lastChild;
  for (var /** @type {number} */ i = len; i >= 0; i--) {
    var /** @type {XML} */ child = this._children[i];
    if (child.getNodeRef() == XML.ELEMENT) {
      child.normalize();
    } else if (child.getNodeRef() == XML.TEXT) {
      if (lastChild && lastChild.getNodeRef() == XML.TEXT) {
        child.setValue(child.XML_s() + lastChild.XML_s());
        this.XML_deleteChildAt((i + 1) >> 0);
      }
      if (!child.XML_s()) {
        this.XML_deleteChildAt(i);
        continue;
      }
    }
    lastChild = child;
  }
  return this;
};


/**
 * Returns the parent of the XML object.
 *
 * @asreturn
 *
 * @return {*}
 */
XML.prototype.parent = function() {
  return this.XML__parent;
};


/**
 * @param {*} rightHand
 * @return {*}
 */
XML.prototype.plus = function(rightHand) {
  var /** @type {XMLList} */ list = new XMLList();
  list.append(this);
  return list.concat(rightHand);
};


/**
 * @private
 * @param {*} value
 * @return {XML}
 */
XML.prototype.XML_xmlFromStringable = function(value) {
  var /** @type {string} */ str = value.toString();
  var /** @type {XML} */ xml = new XML();
  xml.setValue(str);
  return xml;
};


/**
 * Inserts the provided child object into the XML element before any existing XML properties for that element.
 * @asparam value
 * @asreturn
 *
 * @param {XML} child
 * @return {XML}
 */
XML.prototype.prependChild = function(child) {
  var /** @type {string} */ childType = typeof(child);
  if (childType != "object")
    child = this.XML_xmlFromStringable(child);
  this.XML_prependChildInternal(child);
  this.normalize();
  return this;
};


/**
 *
 * @royaleignorecoercion XML
 * @royaleignorecoercion XMLList
 * @private
 * @param {*} child
 */
XML.prototype.XML_prependChildInternal = function(child) {
  if (org.apache.royale.utils.Language.is(child, XMLList)) {
    var /** @type {number} */ len = child.length();
    for (var /** @type {number} */ i = 0; i < len; i++) {
      this.XML_prependChildInternal(child[0]);
    }
  } else {
    org.apache.royale.debugging.assertType(child, XML, "Type must be XML");
    child.setParent(this);
    this.XML_getChildren().unshift(child);
  }
};


/**
 * If a name parameter is provided, lists all the children of the XML object that contain processing instructions with that name.
 *
 * @asparam name
 * @asreturn
 *
 * @royaleignorecoercion XML
 * @param {string=} name
 * @return {XMLList}
 */
XML.prototype.processingInstructions = function(name) {
  name = typeof name !== 'undefined' ? name : "*";
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].getNodeRef() == XML.PROCESSING_INSTRUCTION)
      list.append(this._children[i]);
  }
  list.targetObject = this;
  return list;
};


/**
 * Removes the given child for this object and returns the removed child.
 *
 * @asparam child
 * @asreturn
 *
 * @royaleignorecoercion QName
 * @param {XML} child
 * @return {boolean}
 */
XML.prototype.removeChild = function(child) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  var /** @type {XML} */ removed;
  if (!child)
    return false;
  if (org.apache.royale.utils.Language.is(child, XMLList)) {
    var /** @type {boolean} */ val = false;
    len = child.length();
    for (i = (len - 1) >> 0; i >= 0; i--) {
      if (this.removeChild(child[i])) {
        val = true;
      }
    }
    return val;
  }
  if (!org.apache.royale.utils.Language.is(child, XML))
    return this.XML_removeChildByName(child);
  if (child.getNodeRef() == XML.ATTRIBUTE) {
    len = this.attributeLength();
    for (i = 0; i < len; i++) {
      if (child.equals(this._attributes[i])) {
        removed = this._attributes[i];
        removed.XML__parent = null;
        this._attributes.splice(i, 1);
        this.xml$_notify("attributeRemoved", this, removed._name.localName, removed.getValue());
        return true;
      }
    }
    return false;
  }
  var /** @type {number} */ idx = this.getIndexOf(child);
  if (idx < 0)
    return false;
  this._children.splice(idx, 1);
  child.XML__parent = null;
  this.xml$_notify("nodeRemoved", this, child, null);
  return true;
};


/**
 *
 * @royaleignorecoercion XML
 * @royaleignorecoercion QName
 * @private
 * @param {*} name
 * @return {boolean}
 */
XML.prototype.XML_removeChildByName = function(name) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  var /** @type {QName} */ qName = this.XML_toXMLName(name);
  var /** @type {XML} */ child;
  var /** @type {boolean} */ removedItem = false;
  if (qName.isAttribute) {
    len = (this.attributeLength() - 1) >> 0;
    for (i = len; i >= 0; i--) {
      child = this._attributes[i];
      if (qName.matches(child.name())) {
        child = this._attributes[i];
        child.XML__parent = null;
        this._attributes.splice(i, 1);
        removedItem = true;
        this.xml$_notify("attributeRemoved", this, child._name.localName, child.getValue());
      }
    }
    return removedItem;
  }
  len = (this.childrenLength() - 1) >> 0;
  for (i = len; i >= 0; i--) {
    child = this._children[i];
    if (child.getNodeRef() != XML.ELEMENT && qName.localName != '*') {
      continue;
    }
    if (qName.matches(child.name())) {
      child = this._children[i];
      child.XML__parent = null;
      this._children.splice(i, 1);
      removedItem = true;
      this.xml$_notify("nodeRemoved", this, child, null);
    }
  }
  this.normalize();
  return removedItem;
};


/**
 * @param {number} index
 * @return {boolean}
 */
XML.prototype.removeChildAt = function(index) {
  if (index < this.childrenLength()) {
    var /** @type {XML} */ removed = this._children[index];
    if (removed) {
      removed.setParent(null);
      index = (this._children.indexOf(removed)) >> 0;
      if (index != -1) {
        this._children.splice(index, 1);
        this.xml$_notify("nodeRemoved", this, removed, null);
      }
    }
    return true;
  }
  throw new TypeError("Cannot call delete on XML at index " + index);
};


/**
 * Removes the given namespace for this object and all descendants.
 *
 * @asparam ns
 * @asreturn
 *
 * @royaleignorecoercion XML
 * @param {*} ns
 * @return {XML}
 */
XML.prototype.removeNamespace = function(ns) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  var /** @type {string} */ ref = this.getNodeRef();
  if (ref == XML.TEXT || ref == XML.COMMENT || ref == XML.PROCESSING_INSTRUCTION || ref == XML.ATTRIBUTE)
    return this;
  if (!org.apache.royale.utils.Language.is(ns, Namespace))
    ns = new Namespace(ns);
  if (ns == this.name().getNamespace(this._namespaces))
    return this;
  len = this.attributeLength();
  for (i = 0; i < len; i++) {
    if (ns == this._attributes[i].name().getNamespace(this._namespaces))
      return this;
  }
  len = this.namespaceLength();
  for (i = (len - 1) >> 0; i >= 0; i--) {
    if (this._namespaces[i].uri == ns.uri && this._namespaces[i].prefix == ns.prefix)
      this._namespaces.splice(i, 1);
    else if (ns.prefix == null && this._namespaces[i].uri == ns.uri)
      this._namespaces.splice(i, 1);
  }
  len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].getNodeRef() == XML.ELEMENT)
      this._children[i].removeNamespace(ns);
  }
  this.xml$_notify("namespaceRemoved", this, ns, null);
  return this;
};


/**
 * Replaces the properties specified by the propertyName parameter with the given value parameter.
 *
 * @asparam propertyName
 * @asparam value
 * @asreturn
 *
 * @royaleignorecoercion XML
 *
 * @param {Object} propertyName
 * @param {*} value
 * @return {*}
 */
XML.prototype.replace = function(propertyName, value) {
  var /** @type {string} */ ref = this.getNodeRef();
  if (ref == XML.TEXT || ref == XML.COMMENT || ref == XML.PROCESSING_INSTRUCTION || ref == XML.ATTRIBUTE) {
    return this.XML_s().replace(propertyName, value);
  }
  if (org.apache.royale.utils.Language.is(value, XML) || org.apache.royale.utils.Language.is(value, XMLList))
    value = value.copy();
  else
    value = value + '';
  var /** @type {number} */ idx = (parseInt(propertyName, 10)) >>> 0;
  if (idx.toString() == propertyName + '') {
    this.replaceChildAt((idx) >> 0, value);
    return this;
  }
  var /** @type {QName} */ n = this.XML_toXMLName(propertyName);
  var /** @type {number} */ i = -1;
  var /** @type {number} */ k = (this.childrenLength() - 1) >>> 0;
  var /** @type {XML} */ replaceChild = null;
  for (; k > -1; k--) {
    var /** @type {XML} */ childK = this._children[k];
    if (((n.localName == "*") || ((childK.getNodeRef() == XML.ELEMENT) && (childK.localName() == n.localName))) && ((n.uri == null) || ((childK.getNodeRef() == XML.ELEMENT) && (childK.name().uri == n.uri)))) {
      if (i != -1) {
        this.XML_deleteChildAt(i);
        this.xml$_notify("nodeRemoved", this, replaceChild, null);
      }
      i = (k) >> 0;
      replaceChild = childK;
    }
  }
  if (i == -1)
    return this;
  this.XML__internalSuppressNotify = true;
  this.replaceChildAt(i, value);
  this.XML__internalSuppressNotify = false;
  this.xml$_notify("nodeChanged", this, this._children[i], replaceChild);
  return this;
};


/**
 *
 * @royaleignorecoercion XML
 * @royaleignorecoercion XMLList
 * @param {number} idx
 * @param {*} v
 */
XML.prototype.replaceChildAt = function(idx, v) {
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ len = 0;
  var /** @type {string} */ ref = this.getNodeRef();
  if (ref == XML.TEXT || ref == XML.COMMENT || ref == XML.PROCESSING_INSTRUCTION || ref == XML.ATTRIBUTE)
    return;
  len = this.childrenLength();
  if (idx > len)
    idx = len;
  this.XML_getChildren();
  if (org.apache.royale.utils.Language.is(v, XML) && v.getNodeRef() != XML.ATTRIBUTE) {
    if (v.getNodeRef() == XML.ELEMENT && (v == this || this.XML_isAncestor(v)))
      throw new TypeError("cannot assign parent xml as child");
    v.setParent(this);
    if (this._children[idx])
      this.removeChild(this._children[idx]);
    this.XML_insertChildAt(v, idx);
  } else if (org.apache.royale.utils.Language.is(v, XMLList)) {
    len = v.length();
    if (this._children[idx])
      this._children[idx].XML__parent = null;
    if (len) {
      v[0].setParent(this);
      this._children[idx] = v[0];
      var /** @type {number} */ listIdx = 1;
      var /** @type {XML} */ chld = v[0];
      while (listIdx < len) {
        chld = v[listIdx];
        this.XML_insertChildAt(chld, (idx + listIdx) >> 0);
        listIdx++;
      }
    } else {
      this._children.splice(idx, 1);
    }
  } else {
    chld = new XML();
    chld.setValue(v + '');
    chld.setParent(this);
    if (this._children[idx] != null)
      this._children[idx].setParent(null);
    this._children[idx] = chld;
  }
};


/**
 * @private
 * @param {XML} xml
 * @return {boolean}
 */
XML.prototype.XML_isAncestor = function(xml) {
  var /** @type {XML} */ p = this.XML__parent;
  while (p) {
    if (p == xml)
      return true;
    p = p.XML__parent;
  }
  return false;
};


/**
 *
 * @royaleignorecoercion XML
 * @param {*} attr
 * @param {string} value
 * @return {string}
 */
XML.prototype.setAttribute = function(attr, value) {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  value = "" + value;
  this.XML_getAttributes();
  if (org.apache.royale.utils.Language.is(attr, XML)) {
    if (attr.getNodeRef() == XML.ATTRIBUTE) {
      var /** @type {number} */ len = this.attributeLength();
      for (i = 0; i < len; i++) {
        if (this._attributes[i].name().equals(attr.name())) {
          var /** @type {string} */ oldValue = org.apache.royale.utils.Language.string(this._attributes[i].getValue());
          this._attributes[i].setValue(value);
          this.xml$_notify("attributeChanged", this, attr.name().toString(), oldValue);
          return value;
        }
      }
      attr.setValue(value);
      this.addChild(attr);
    }
    return value;
  }
  if (typeof(attr) == 'string' && attr.indexOf("xmlns") == 0) {
    var /** @type {Namespace} */ ns;
    var /** @type {number} */ prfIdx = (attr.indexOf(":")) >> 0;
    if (prfIdx != -1) {
      ns = new Namespace(attr.substring(prfIdx + 1), value.toString());
    }
    else
      ns = new Namespace(value.toString());
    this.addNamespace(ns);
  } else {
    var /** @type {XML} */ attrXML = new XML();
    var /** @type {QName} */ nameRef = org.apache.royale.language.toAttributeName(attr);
    attrXML._name = XML.getQName(nameRef.localName, nameRef.prefix, nameRef.uri, true);
    attrXML.setValue(value);
    len = this.attributeLength();
    for (i = 0; i < len; i++) {
      if (this._attributes[i].name().equals(attrXML.name())) {
        var /** @type {string} */ oldValueX = this._attributes[i].getValue();
        this._attributes[i].setValue(value);
        this.xml$_notify("attributeChanged", this, attrXML.name().toString(), oldValueX);
        return value;
      }
    }
    this.addChild(attrXML);
  }
  return value;
};


/**
 * Replaces the child properties of the XML object with the specified name with the specified XML or XMLList.
 * This is primarily used to support dot notation assignment of XML.
 *
 * @asparam value
 * @asreturn
 *
 * @royaleignorecoercion QName
 * @royaleignorecoercion XML
 * @param {*} elementName
 * @param {Object} elements
 * @return {Object}
 */
XML.prototype.setChild = function(elementName, elements) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  if (org.apache.royale.utils.Language.uint(elementName).toString() == elementName)
    throw new TypeError('not permitted');
  var /** @type {string} */ ref = this.getNodeRef();
  if (ref == XML.TEXT || ref == XML.COMMENT || ref == XML.PROCESSING_INSTRUCTION || ref == XML.ATTRIBUTE)
    return this;
  var /** @type {QName} */ n = this.XML_toXMLName(elementName);
  if (n.isAttribute) {
    return this.setAttribute(n, elements + '');
  }
  i = -1;
  var /** @type {boolean} */ wild = n.localName == '*';
  var /** @type {boolean} */ primitiveAssign = !wild && !(org.apache.royale.utils.Language.is(elements, XML) || org.apache.royale.utils.Language.is(elements, XMLList));
  var /** @type {number} */ k = (this.childrenLength() - 1) >> 0;
  while (k > -1) {
    if ((wild || (this._children[k].getNodeRef() == XML.ELEMENT && this._children[k].localName() == n.localName)) && (n.uri == null || (this._children[k].getNodeRef() == XML.ELEMENT && this._children[k]._name.uri == n.uri))) {
      if (i !== -1) {
        this.removeChildAt(i);
      }
      i = k;
    }
    k--;
  }
  if (i == -1) {
    i = this.childrenLength();
    if (primitiveAssign) {
      XML._internal = true;
      var /** @type {XML} */ y = new XML();
      XML._internal = false;
      y._name = XML.getQName(n.localName, n.prefix, n.uri, false);
      y.setParent(this);
      var /** @type {Namespace} */ ns = new Namespace('', n);
      this.replaceChildAt(i, y);
      y.setNamespace(ns);
    }
  }
  if (primitiveAssign) {
    y = this._children[i];
    if (this.XML__notification || (XML.recursiveNotify && this.XML__parent)) {
      len = y.childrenLength();
      var /** @type {string} */ firstChildStr = null;
      for (k = 0; k < len; ++k) {
        var /** @type {XML} */ removed = y._children[k];
        if (!k)
          firstChildStr = removed.toXMLString();
        y.xml$_notify("nodeRemoved", y, removed, null);
      }
    }
    k = (y.childrenLength() - 1) >> 0;
    y.XML__internalSuppressNotify = true;
    while (k > -1) {
      y.removeChildAt(0);
      k--;
    }
    y.XML__internalSuppressNotify = false;
    elements = elements + '';
    if (elements) {
      y.replaceChildAt(0, elements);
      if (this.XML__notification || (XML.recursiveNotify && this.XML__parent)) {
        y.xml$_notify("textSet", y._children[0], elements, new XML(firstChildStr));
      }
    }
  } else {
    this.replaceChildAt(i, elements);
  }
  return elements;
};


/**
 * Replaces the child properties of the XML object with the specified set of XML properties, provided in the value parameter.
 *
 * @asparam value
 * @asreturn
 *
 * @param {Object} value
 * @return {XML}
 */
XML.prototype.setChildren = function(value) {
  var /** @type {number} */ len = 0;
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  var /** @type {XML} */ chld;
  if (org.apache.royale.utils.Language.is(value, XML)) {
    var /** @type {XMLList} */ list = new XMLList();
    list.setChild(0, value);
    value = list;
  }
  if (org.apache.royale.utils.Language.is(value, XMLList)) {
    var /** @type {XMLList} */ chldrn = this.children();
    var /** @type {number} */ childIdx = (chldrn.length() - 1) >> 0;
    if (chldrn.length())
      childIdx = (chldrn[0].childIndex()) >> 0;
    len = (chldrn.length() - 1) >> 0;
    var /** @type {XML} */ origFirstChild = null;
    this.XML__internalSuppressNotify = true;
    for (i = len; i >= 0; i--) {
      this.removeChild(chldrn[i]);
      if (i > 0) {
        this.XML__internalSuppressNotify = false;
        this.xml$_notify("nodeRemoved", this, chldrn[i], null);
        this.XML__internalSuppressNotify = true;
      } else {
        origFirstChild = chldrn[i];
      }
    }
    this.XML__internalSuppressNotify = false;
    var /** @type {XML} */ curChild = this.XML_getChildren()[childIdx];
    var /** @type {XML} */ firstChild = null;
    len = (value.length()) >> 0;
    this.XML__internalSuppressNotify = true;
    for (i = 0; i < len; i++) {
      chld = value[i];
      if (!firstChild)
        firstChild = chld;
      if (!curChild) {
        curChild = chld;
        this.appendChild(chld);
      } else {
        this.insertChildAfter(curChild, chld);
        curChild = chld;
      }
    }
    this.XML__internalSuppressNotify = false;
    if (len > 0) {
      this.xml$_notify(origFirstChild ? "nodeChanged" : "nodeAdded", this, firstChild, origFirstChild);
    }
  }
  return this;
};


/**
 * Changes the local name of the XML object to the given name parameter.
 *
 * @asparam name
 *
 * @param {string} name
 */
XML.prototype.setLocalName = function(name) {
  if (!this._name)
    this._name = new QName();
  var /** @type {QName} */ oldName = this._name;
  this._name = XML.getQName(name, this._name.prefix, org.apache.royale.utils.Language.string(this._name.uri), !!(this._name.isAttribute));
  this.xml$_notify("nameSet", (this.getNodeRef() == XML.ATTRIBUTE ? this.XML_xmlFromStringable(this.getValue()) : this), this._name.toString(), oldName.toString());
};


/**
 * Sets the name of the XML object to the given qualified name or attribute name.
 *
 * @asparam name
 *
 * @param {*} name
 */
XML.prototype.setName = function(name) {
  var /** @type {string} */ ref = this.getNodeRef();
  if (ref == XML.TEXT || ref == XML.COMMENT)
    return;
  var /** @type {QName} */ nameRef;
  if (org.apache.royale.utils.Language.is(name, QName))
    nameRef = name;
  else
    nameRef = new QName(name);
  var /** @type {boolean} */ asAtttribute = nameRef.isAttribute;
  var /** @type {QName} */ oldName = this._name;
  this._name = XML.getQName(nameRef.localName, nameRef.prefix, nameRef.uri, asAtttribute);
  if (asAtttribute) {
    delete this.XML__nodeKind;
  }
  if (oldName)
    this.xml$_notify("nameSet", (ref == XML.ATTRIBUTE ? this.XML_xmlFromStringable(this.getValue()) : this), (org.apache.royale.utils.Language.is(name, QName) ? this._name : this._name.toString()), oldName.toString());
};


/**
 * Sets the namespace associated with the XML object.
 *
 * @asparam ns
 *
 * @param {Object} ns
 */
XML.prototype.setNamespace = function(ns) {
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.TEXT || kind == XML.COMMENT || kind == XML.PROCESSING_INSTRUCTION)
    return;
  var /** @type {Namespace} */ ns2 = new Namespace(ns);
  var /** @type {QName} */ nameRef = new QName(ns2, this.name());
  if (kind == XML.ATTRIBUTE) {
    if (this.XML__parent == null)
      return;
    nameRef.setIsAttribute(true);
    this.XML__parent.addNamespaceInternal(ns2);
  }
  this._name = XML.getQName(nameRef.localName, nameRef.prefix, nameRef.uri, nameRef.isAttribute);
  if (kind == XML.ELEMENT) {
    this.addNamespaceInternal(ns2);
  }
  this.xml$_notify("namespaceSet", this, ns, null);
};


/**
 * @asprivate
 *
 * @param {string} value
 */
XML.prototype.setNodeKind = function(value) {
  if (this.getNodeKindInternal() != value) {
    var /** @type {string} */ kind = org.apache.royale.utils.Language.string(XML.kindRefLookup[value]);
    if (kind) {
      this.XML__nodeKind = kind;
    }
  }
};


/**
 * @asprivate
 * @royalesuppressexport
 * @param {XML} parent
 * @param {boolean=} keep
 */
XML.prototype.setParent = function(parent, keep) {
  keep = typeof keep !== 'undefined' ? keep : false;
  if (parent == this.XML__parent)
    return;
  var /** @type {XML} */ oldParent = this.XML__parent;
  if (oldParent && !keep)
    oldParent.removeChild(this);
  this.XML__parent = parent;
};


/**
 * @param {string} value
 */
XML.prototype.setValue = function(value) {
  if (value) {
    this._value = value;
  } else {
    delete this._value;
  }
};


/**
 * Returns an XMLList object of all XML properties of the XML object that represent XML text nodes.
 *
 * @asreturn
 *
 * @return {XMLList}
 */
XML.prototype.text = function() {
  var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  //var /** @type {number} */ i = 0;
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    var /** @type {XML} */ child = this._children[i];
    if (child.getNodeRef() == XML.TEXT)
      list.append(child);
  }
  list.targetObject = this;
  return list;
};


/**
 * Returns a string representation of the XML object.
 *
 * @asreturn
 *
 * @return {string}
 */
XML.prototype.toString = function() {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {string} */ kind = this.getNodeRef();
  if (kind == XML.ATTRIBUTE)
    return this.getValue();
  if (kind == XML.TEXT) {
    var /** @type {string} */ textVal = this.getValue();
    return textVal.indexOf('<![CDATA[') == 0 ? textVal.substring(9, textVal.length - 3) : textVal;
  }
  if (kind == XML.COMMENT)
    return "";
  if (kind == XML.PROCESSING_INSTRUCTION)
    return "";
  if (this.hasSimpleContent()) {
    var /** @type {string} */ s = "";
    var /** @type {number} */ len = this.childrenLength();
    for (i = 0; i < len; i++) {
      var /** @type {XML} */ child = this._children[i];
      var /** @type {string} */ childKind = child.getNodeRef();
      if (childKind == XML.COMMENT || childKind == XML.PROCESSING_INSTRUCTION)
        continue;
      s = s + child.toString();
    }
    return s;
  }
  return this.toXMLString();
};


/**
 *
 * @royaleignorecoercion QName
 * @private
 * @param {*} name
 * @return {QName}
 */
XML.prototype.XML_toXMLName = function(name) {
  
/**
 * @const
 * @type {string}
 */
var typeName = typeof(name);
  if (name == null || typeName == 'number' || typeName == 'boolean') {
    throw new TypeError('invalid xml name');
  }
  if (org.apache.royale.utils.Language.is(name, QName)) {
    return name;
  }
  var /** @type {string} */ str = name.toString();
  if (parseInt(str, 10).toString() == name)
    throw new TypeError("invalid element name");
  var /** @type {boolean} */ isAttribute = str.charCodeAt(0) == 64;
  if (isAttribute)
    str = str.slice(1);
  var /** @type {QName} */ qname = new QName(str);
  if (isAttribute)
    qname.setIsAttribute(true);
  return qname;
};


/**
 * Returns a string representation of the XML object.
 *
 * @asreturn
 *
 * @return {string}
 */
XML.prototype.toXMLString = function() {
  return this._toXMLString();
};


/**
 *
 * @royaleignorecoercion XML
 * @protected
 * @param {number=} indentLevel
 * @param {Array=} ancestors
 * @return {string}
 */
XML.prototype._toXMLString = function(indentLevel, ancestors) {
  indentLevel = typeof indentLevel !== 'undefined' ? indentLevel : 0;
  ancestors = typeof ancestors !== 'undefined' ? ancestors : null;
  var /** @type {number} */ i = 0;
  var /** @type {number} */ nextIndentLevel = 0;
  var /** @type {number} */ len = 0;
  //var /** @type {number} */ i = 0;
  //var /** @type {number} */ len = 0;
  var /** @type {Namespace} */ ns;
  var /** @type {Array} */ strArr = [];
  indentLevel = (isNaN(indentLevel) ? 0 : indentLevel) >> 0;
  var /** @type {Array} */ indentArr = [];
  for (i = 0; i < indentLevel; i++)
    indentArr.push(XML._indentStr);
  var /** @type {string} */ indent = indentArr.join("");
  
/**
 * @const
 * @type {string}
 */
var nodeType = this.getNodeRef();
  var /** @type {string} */ strValue = this.getValue();
  if (nodeType == XML.TEXT) {
    if (XML.prettyPrinting) {
      var /** @type {string} */ v = strValue.trim();
      if (v.indexOf('<![CDATA[') == 0) {
        return indent + v;
      }
      return indent + XML.escapeElementValue(v);
    }
    if (strValue.indexOf('<![CDATA[') == 0)
      return strValue;
    return XML.escapeElementValue(strValue);
  }
  if (nodeType == XML.ATTRIBUTE)
    return indent + XML.escapeAttributeValue(strValue);
  if (nodeType == XML.COMMENT)
    return indent + "<!--" + strValue + "-->";
  if (nodeType == XML.PROCESSING_INSTRUCTION)
    return indent + "<?" + this.name().localName + " " + strValue + "?>";
  var /** @type {Array} */ inScopeNS;
  if (!ancestors) {
    ancestors = [];
    inScopeNS = this.inScopeNamespaces();
  }
  else
    inScopeNS = this._namespaces ? this._namespaces : [];
  var /** @type {QName} */ myQName = this._name;
  var /** @type {Array} */ declarations;
  if (ancestors.length == 0) {
    declarations = inScopeNS;
  } else {
    declarations = [];
    len = (inScopeNS.length) >> 0;
    for (i = 0; i < len; i++) {
      if (!XML.namespaceInArray(inScopeNS[i], ancestors))
        declarations.push(new Namespace(inScopeNS[i]));
    }
  }
  len = this.attributeLength();
  for (i = 0; i < len; i++) {
    ns = new Namespace(this._attributes[i].name().getNamespace(declarations.concat(ancestors)));
    if (ns.prefix === null) {
      ns.setPrefix("");
      declarations.push(ns);
    }
  }
  ns = new Namespace(myQName.getNamespace(declarations.concat(ancestors)));
  if (ns.prefix === null) {
    ns.setPrefix("");
    declarations.push(ns);
  }
  if (XML.prettyPrinting && indentLevel > 0) {
    strArr.push(new Array(indentLevel + 1).join(XML._indentStr));
  }
  strArr.push("<");
  if (ns.prefix)
    strArr.push(ns.prefix + ":");
  strArr.push(myQName.localName);
  len = this.attributeLength();
  for (i = 0; i < len; i++) {
    strArr.push(" ");
    var /** @type {QName} */ aName = this._attributes[i].name();
    var /** @type {Namespace} */ ans = aName.getNamespace(declarations.concat(ancestors));
    if (ans.prefix) {
      strArr.push(ans.prefix);
      strArr.push(":");
    }
    strArr.push(aName.localName);
    strArr.push('="');
    strArr.push(XML.escapeAttributeValue(this._attributes[i].getValue()));
    strArr.push('"');
  }
  for (i = 0; i < declarations.length; i++) {
    var /** @type {string} */ decVal = XML.escapeAttributeValue(declarations[i].uri);
    if (decVal) {
      strArr.push(" xmlns");
      if (declarations[i].prefix) {
        strArr.push(":");
        strArr.push(declarations[i].prefix);
      }
      strArr.push('="');
      strArr.push(decVal);
      strArr.push('"');
    }
  }
  len = this.childrenLength();
  if (len == 0) {
    strArr.push("/>");
    return strArr.join("");
  }
  strArr.push(">");
  var /** @type {boolean} */ indentChildren = len > 1 || (len == 1 && this._children[0].getNodeRef() != XML.TEXT);
  //var /** @type {number} */ nextIndentLevel = 0;
  if (XML.prettyPrinting && indentChildren)
    nextIndentLevel = (indentLevel + 1) >> 0;
  else
    nextIndentLevel = 0;
  for (i = 0; i < len; i++) {
    if (XML.prettyPrinting && indentChildren)
      strArr.push("\n");
    strArr.push(this._children[i]._toXMLString(nextIndentLevel, ancestors.concat(declarations)));
  }
  if (XML.prettyPrinting && indentChildren) {
    strArr.push("\n");
    if (indentLevel > 0)
      strArr.push(new Array(indentLevel + 1).join(XML._indentStr));
  }
  strArr.push("</");
  if (ns.prefix) {
    strArr.push(ns.prefix);
    strArr.push(":");
  }
  strArr.push(myQName.localName);
  strArr.push(">");
  return strArr.join("");
};


/**
 * @param {number} index
 * @return {string}
 */
XML.prototype.charAt = function(index) {
  return this.XML_s().charAt(index);
};


/**
 * @param {number} index
 * @return {number}
 */
XML.prototype.charCodeAt = function(index) {
  return this.XML_s().charCodeAt(index);
};


/**
 * @param {number} pos
 * @return {number}
 */
XML.prototype.codePointAt = function(pos) {
  return this.XML_s().codePointAt(pos);
};


/**
 * @param {string} searchValue
 * @param {number=} fromIndex
 * @return {number}
 */
XML.prototype.indexOf = function(searchValue, fromIndex) {
  fromIndex = typeof fromIndex !== 'undefined' ? fromIndex : 0;
  return this.XML_s().indexOf(searchValue, fromIndex);
};


/**
 * @param {string} searchValue
 * @param {number=} fromIndex
 * @return {number}
 */
XML.prototype.lastIndexOf = function(searchValue, fromIndex) {
  fromIndex = typeof fromIndex !== 'undefined' ? fromIndex : 0;
  return this.XML_s().lastIndexOf(searchValue, fromIndex);
};


/**
 * @param {string} compareString
 * @param {*=} locales
 * @param {*=} options
 * @return {number}
 */
XML.prototype.localeCompare = function(compareString, locales, options) {
  locales = typeof locales !== 'undefined' ? locales : undefined;
  options = typeof options !== 'undefined' ? options : undefined;
  return this.XML_s().localeCompare(compareString, locales, options);
};


/**
 * @param {*} regexp
 * @return {Array}
 */
XML.prototype.match = function(regexp) {
  return this.XML_s().match(regexp);
};


/**
 * @param {*} regexp
 * @return {number}
 */
XML.prototype.search = function(regexp) {
  return this.XML_s().search(regexp);
};


/**
 * @param {number} beginSlice
 * @param {*=} endSlice
 * @return {string}
 */
XML.prototype.slice = function(beginSlice, endSlice) {
  endSlice = typeof endSlice !== 'undefined' ? endSlice : undefined;
  return org.apache.royale.utils.Language.string(this.XML_s()["slice"](beginSlice, endSlice));
};


/**
 * @param {*=} separator
 * @param {*=} limit
 * @return {Array}
 */
XML.prototype.split = function(separator, limit) {
  separator = typeof separator !== 'undefined' ? separator : undefined;
  limit = typeof limit !== 'undefined' ? limit : undefined;
  return this.XML_s()["split"](separator, limit);
};


/**
 * @param {number} start
 * @param {*=} length
 * @return {string}
 */
XML.prototype.substr = function(start, length) {
  length = typeof length !== 'undefined' ? length : undefined;
  return org.apache.royale.utils.Language.string(this.XML_s()["substr"](start, length));
};


/**
 * @param {number} indexStart
 * @param {*=} indexEnd
 * @return {string}
 */
XML.prototype.substring = function(indexStart, indexEnd) {
  indexEnd = typeof indexEnd !== 'undefined' ? indexEnd : undefined;
  return org.apache.royale.utils.Language.string(this.XML_s()["substring"](indexStart, indexEnd));
};


/**
 * @return {string}
 */
XML.prototype.toLocaleLowerCase = function() {
  return this.XML_s().toLocaleLowerCase();
};


/**
 * @return {string}
 */
XML.prototype.toLocaleUpperCase = function() {
  return this.XML_s().toLocaleUpperCase();
};


/**
 * @return {string}
 */
XML.prototype.toLowerCase = function() {
  return this.XML_s().toLowerCase();
};


/**
 * @return {string}
 */
XML.prototype.toUpperCase = function() {
  return this.XML_s().toUpperCase();
};


/**
 * @return {string}
 */
XML.prototype.trim = function() {
  return this.XML_s().trim();
};


/**
 * @royaleignorecoercion Number
 * @param {*=} fractionDigits
 * @return {number}
 */
XML.prototype.toExponential = function(fractionDigits) {
  fractionDigits = typeof fractionDigits !== 'undefined' ? fractionDigits : undefined;
  return this.XML_v()["toExponential"](fractionDigits);
};


/**
 * @royaleignorecoercion Number
 * @param {number=} digits
 * @return {number}
 */
XML.prototype.toFixed = function(digits) {
  digits = typeof digits !== 'undefined' ? digits : 0;
  return this.XML_v().toFixed(digits);
};


/**
 * @royaleignorecoercion Number
 * @param {*=} precision
 * @return {number}
 */
XML.prototype.toPrecision = function(precision) {
  precision = typeof precision !== 'undefined' ? precision : undefined;
  return this.XML_v()["toPrecision"](precision);
};


/**
 * @private
 * @return {string}
 */
XML.prototype.XML_s = function() {
  return this.toString();
};


/**
 * @private
 * @return {number}
 */
XML.prototype.XML_v = function() {
  return Number(this.XML_s());
};


/**
 * @private
 * @type {Function}
 */
XML.prototype.XML__notification;


/**
 * @private
 * @type {boolean}
 */
XML.prototype.XML__internalSuppressNotify;


/**
 * @param {string} type
 * @param {Object} target
 * @param {Object} value
 * @param {Object} detail
 */
XML.prototype.xml$_notify = function(type, target, value, detail) {
  if (this.XML__internalSuppressNotify)
    return;
  if (this.XML__notification)
    this.XML__notification(this, type, target, value, detail, this.XML__notification);
  if (XML.recursiveNotify && this.XML__parent)
    this.XML__parent.xml$_notify(type, target, value, detail);
};


/**
 * @return {Function}
 */
XML.prototype.notification = function() {
  return this.XML__notification;
};


/**
 * Callback function for change notification:
 *
 *   function xmlNotificationEx(
 *     currentTarget:Object, 
 *     type:String, 
 *     target:Object, 
 *     value:Object, 
 *     detail:Object,
 *     callee:Function = null):void
 *
 * type
 *
 *   attributeAdded
 *   attributeChanged
 *   attributeRemoved
 *   nodeAdded
 *   nodeRemoved
 *   namespaceAdded
 *   namespaceSet
 *   namespaceRemoved
 *   nameSet
 *   textSet
 *
 *   NOT IMPLEMENTED YET:
 *
 *   nodeChanged
 * @param {Function} callback
 */
XML.prototype.setNotification = function(callback) {
  this.XML__notification = callback;
  this.XML__internalSuppressNotify = false;
};


/**
 * @nocollapse
 * @export
 * @type {*}
 */
XML.prototype.targetObject;


XML.prototype.get__targetObject = function() {
  return null;
};


Object.defineProperties(XML.prototype, /** @lends {XML.prototype} */ {
/**
 * @type {*}
 */
targetObject: {
get: XML.prototype.get__targetObject}}
);


/**
 * @nocollapse
 * @export
 * @type {number}
 */
XML.prettyIndent;


XML.get__prettyIndent = function() {
  return (XML._prettyIndent) >> 0;
};


XML.set__prettyIndent = function(value) {
  XML._prettyIndent = value;
  XML._indentStr = "";
  for (var /** @type {number} */ i = 0; i < value; i++) {
    XML._indentStr = XML._indentStr + XML.INDENT_CHAR;
  }
};


Object.defineProperties(XML, /** @lends {XML} */ {
/**
 * @type {number}
 */
prettyIndent: {
get: XML.get__prettyIndent,
set: XML.set__prettyIndent}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
XML.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'XML', qName: 'XML', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
XML.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '|ignoreComments': { type: 'Boolean', get_set: function (/** * */ v) {return v !== undefined ? XML.ignoreComments = v : XML.ignoreComments;}},
        '|ignoreProcessingInstructions': { type: 'Boolean', get_set: function (/** * */ v) {return v !== undefined ? XML.ignoreProcessingInstructions = v : XML.ignoreProcessingInstructions;}},
        '|ignoreWhitespace': { type: 'Boolean', get_set: function (/** * */ v) {return v !== undefined ? XML.ignoreWhitespace = v : XML.ignoreWhitespace;}},
        '|prettyPrinting': { type: 'Boolean', get_set: function (/** * */ v) {return v !== undefined ? XML.prettyPrinting = v : XML.prettyPrinting;}},
        '|recursiveNotify': { type: 'Boolean', get_set: function (/** * */ v) {return v !== undefined ? XML.recursiveNotify = v : XML.recursiveNotify;}}
      };
    },
    accessors: function () {
      return {
        '|prettyIndent': { type: 'int', access: 'readwrite', declaredBy: 'XML'},
        'targetObject': { type: '*', access: 'readonly', declaredBy: 'XML'}
      };
    },
    methods: function () {
      return {
        '|clearQNameCache': { type: 'void', declaredBy: 'XML'},
        '|defaultSettings': { type: 'Object', declaredBy: 'XML'},
        '|setSettings': { type: 'void', declaredBy: 'XML', parameters: function () { return [ 'Object', false ]; }},
        '|settings': { type: 'Object', declaredBy: 'XML'},
        'XML': { type: '', declaredBy: 'XML', parameters: function () { return [ '*', true ]; }},
        'addChild': { type: 'void', declaredBy: 'XML', parameters: function () { return [ 'XML', false ]; }},
        'addNamespace': { type: 'XML', declaredBy: 'XML', parameters: function () { return [ 'Namespace', false ]; }},
        'addNamespaceInternal': { type: 'XML', declaredBy: 'XML', parameters: function () { return [ 'Namespace', false ]; }},
        'appendChild': { type: 'XML', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'attribute': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'attributes': { type: 'XMLList', declaredBy: 'XML'},
        'child': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [ 'Object', false ]; }},
        'childIndex': { type: 'int', declaredBy: 'XML'},
        'children': { type: 'XMLList', declaredBy: 'XML'},
        'comments': { type: 'XMLList', declaredBy: 'XML'},
        'concat': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'contains': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'copy': { type: 'XML', declaredBy: 'XML'},
        'descendants': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [ 'Object', true ]; }},
        'elements': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [ 'Object', true ]; }},
        'elementNames': { type: 'Array', declaredBy: 'XML'},
        'equals': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'hasAttribute': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [ '*', false ,'String', true ]; }},
        'getAttributeArray': { type: 'Array', declaredBy: 'XML'},
        'getChildrenArray': { type: 'Array', declaredBy: 'XML'},
        'getIndexOf': { type: 'int', declaredBy: 'XML', parameters: function () { return [ 'XML', false ]; }},
        'getValue': { type: 'String', declaredBy: 'XML'},
        'hasAncestor': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'hasComplexContent': { type: 'Boolean', declaredBy: 'XML'},
        'hasOwnProperty': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'hasSimpleContent': { type: 'Boolean', declaredBy: 'XML'},
        'inScopeNamespaces': { type: 'Array', declaredBy: 'XML'},
        'insertChildAfter': { type: 'XML', declaredBy: 'XML', parameters: function () { return [ 'XML', false ,'XML', false ]; }},
        'insertChildBefore': { type: 'XML', declaredBy: 'XML', parameters: function () { return [ 'XML', false ,'XML', false ]; }},
        'length': { type: 'int', declaredBy: 'XML'},
        'localName': { type: 'String', declaredBy: 'XML'},
        'name': { type: 'QName', declaredBy: 'XML'},
        'namespace': { type: '*', declaredBy: 'XML', parameters: function () { return [ 'String', true ]; }},
        'namespaceDeclarations': { type: 'Array', declaredBy: 'XML'},
        'nodeKind': { type: 'String', declaredBy: 'XML'},
        'normalize': { type: 'XML', declaredBy: 'XML'},
        'parent': { type: '*', declaredBy: 'XML'},
        'plus': { type: '*', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'prependChild': { type: 'XML', declaredBy: 'XML', parameters: function () { return [ 'XML', false ]; }},
        'processingInstructions': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [ 'String', true ]; }},
        'removeChild': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [ 'XML', false ]; }},
        'removeChildAt': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [ 'int', false ]; }},
        'removeNamespace': { type: 'XML', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'replace': { type: '*', declaredBy: 'XML', parameters: function () { return [ 'Object', false ,'*', false ]; }},
        'replaceChildAt': { type: 'void', declaredBy: 'XML', parameters: function () { return [ 'int', false ,'*', false ]; }},
        'setAttribute': { type: 'String', declaredBy: 'XML', parameters: function () { return [ '*', false ,'String', false ]; }},
        'setChild': { type: 'Object', declaredBy: 'XML', parameters: function () { return [ '*', false ,'Object', false ]; }},
        'setChildren': { type: 'XML', declaredBy: 'XML', parameters: function () { return [ 'Object', false ]; }},
        'setLocalName': { type: 'void', declaredBy: 'XML', parameters: function () { return [ 'String', false ]; }},
        'setName': { type: 'void', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'setNamespace': { type: 'void', declaredBy: 'XML', parameters: function () { return [ 'Object', false ]; }},
        'setNodeKind': { type: 'void', declaredBy: 'XML', parameters: function () { return [ 'String', false ]; }},
        'setValue': { type: 'void', declaredBy: 'XML', parameters: function () { return [ 'String', false ]; }},
        'text': { type: 'XMLList', declaredBy: 'XML'},
        'toString': { type: 'String', declaredBy: 'XML'},
        'toXMLString': { type: 'String', declaredBy: 'XML'},
        'charAt': { type: 'String', declaredBy: 'XML', parameters: function () { return [ 'Number', false ]; }},
        'charCodeAt': { type: 'Number', declaredBy: 'XML', parameters: function () { return [ 'Number', false ]; }},
        'codePointAt': { type: 'Number', declaredBy: 'XML', parameters: function () { return [ 'Number', false ]; }},
        'indexOf': { type: 'Number', declaredBy: 'XML', parameters: function () { return [ 'String', false ,'Number', true ]; }},
        'lastIndexOf': { type: 'Number', declaredBy: 'XML', parameters: function () { return [ 'String', false ,'Number', true ]; }},
        'localeCompare': { type: 'Number', declaredBy: 'XML', parameters: function () { return [ 'String', false ,'*', true ,'*', true ]; }},
        'match': { type: 'Array', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'search': { type: 'Number', declaredBy: 'XML', parameters: function () { return [ '*', false ]; }},
        'slice': { type: 'String', declaredBy: 'XML', parameters: function () { return [ 'Number', false ,'*', true ]; }},
        'split': { type: 'Array', declaredBy: 'XML', parameters: function () { return [ '*', true ,'*', true ]; }},
        'substr': { type: 'String', declaredBy: 'XML', parameters: function () { return [ 'Number', false ,'*', true ]; }},
        'substring': { type: 'String', declaredBy: 'XML', parameters: function () { return [ 'Number', false ,'*', true ]; }},
        'toLocaleLowerCase': { type: 'String', declaredBy: 'XML'},
        'toLocaleUpperCase': { type: 'String', declaredBy: 'XML'},
        'toLowerCase': { type: 'String', declaredBy: 'XML'},
        'toUpperCase': { type: 'String', declaredBy: 'XML'},
        'trim': { type: 'String', declaredBy: 'XML'},
        'toExponential': { type: 'Number', declaredBy: 'XML', parameters: function () { return [ '*', true ]; }},
        'toFixed': { type: 'Number', declaredBy: 'XML', parameters: function () { return [ 'int', true ]; }},
        'toPrecision': { type: 'Number', declaredBy: 'XML', parameters: function () { return [ '*', true ]; }},
        'xml$_notify': { type: 'void', declaredBy: 'XML', parameters: function () { return [ 'String', false ,'Object', false ,'Object', false ,'Object', false ]; }},
        'notification': { type: 'Function', declaredBy: 'XML'},
        'setNotification': { type: 'void', declaredBy: 'XML', parameters: function () { return [ 'Function', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
XML.prototype.ROYALE_COMPILE_FLAGS = 10;

//# sourceMappingURL=./XML.js.map
