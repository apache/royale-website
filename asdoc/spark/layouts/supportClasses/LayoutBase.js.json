{ "type": "class",
  "qname": "spark.layouts.supportClasses.LayoutBase",
  "baseClassname": "org.apache.royale.core.LayoutBase"
  ,
    "description": "The LayoutBase class defines the base class for all Spark layouts. To create a custom layout that works with the Spark containers, you must extend <code>LayoutBase</code> or one of its subclasses.  <p>At minimum, subclasses must implement the <code>updateDisplayList()</code> method, which positions and sizes the <code>target</code> GroupBase's elements, and the <code>measure()</code> method, which calculates the default size of the <code>target</code>.</p>  <p>Subclasses may override methods like <code>getElementBoundsAboveScrollRect()</code> and <code>getElementBoundsBelowScrollRect()</code> to customize the way the target behaves when it's connected to scrollbars.</p>  <p>Subclasses that support virtualization must respect the <code>useVirtualLayout</code> property and should only retrieve layout elements within the scrollRect (the value of <code>getScrollRect()</code>) using <code>getVirtualElementAt()</code> from within <code>updateDisplayList()</code>.</p>  <p>The <code>&lt;s:LayoutBase&gt;</code> tag inherits all of the tag attributes of its superclass and adds the following tag attributes:</p>  <pre>\\n &lt;s:LayoutBase\\n <strong>Properties</strong>\\n clipAndEnableScrolling=&quot;false&quot;\\n dropIndicator=&quot;<i>defined by the skin class</i>&quot;\\n horizontalScrollPosition=&quot;0&quot;\\n target=&quot;null&quot;\\n typicalLayoutElement=&quot;null&quot;\\n useVirtualLayout=&quot;false&quot;\\n verticalScrollPosition=&quot;0&quot;\\n /&gt;\\n </pre>",
  "tags": [
  {  "tagName": "mxml",
         "values": [""]},
      {  "tagName": "playerversion",
         "values": ["Flash 10", "AIR 1.5"]},
      {  "tagName": "productversion",
         "values": ["Flex 4"]},
      {  "tagName": "langversion",
         "values": ["3.0"]}  ],
  "members": [
  { "type": "method",
        "qname": "spark.layouts.supportClasses.LayoutBase",
        "namespace": "",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Constructor.",
        "tags": [
        {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "",
          "params": []}
      ,
      { "type": "accessor",
        "access": "write-only",
        "return": "org.apache.royale.core.IStrand",
        "qname": "strand",
        "namespace": "public",
        "bindable": [],
        "details": ["override"],
        "deprecated": {}},
      { "type": "accessor",
        "access": "read-write",
        "return": "spark.components.supportClasses.GroupBase",
        "qname": "target",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "The GroupBase container whose elements are measured, sized and positioned by this layout.  <p>Subclasses may override the setter to perform target specific actions. For example a 3D layout may set the target's <code>maintainProjectionCenter</code> property here.</p>",
        "tags": [
        {  "tagName": "default",
               "values": ["null"]},
            {  "tagName": "see",
               "values": ["#updateDisplayList()", "#measure()"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "Boolean",
        "qname": "useVirtualLayout",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "A container can hold any number of children. However, each child requires an instance of an item renderer. If the container has many children, you might notice performance degradation as you add more children to the container.  <p>Instead of creating an item renderer for each child, you can configure the container to use a virtual layout. With virtual layout, the container reuses item renderers so that it only creates item renderers for the currently visible children of the container. As a child is moved off the screen, possible by scrolling the container, a new child being scrolled onto the screen can reuse its item renderer. </p>  <p>To configure a container to use virtual layout, set the <code>useVirtualLayout</code> property to <code>true</code> for the layout associated with the container. Only DataGroup or SkinnableDataContainer with layout set to VerticalLayout, HorizontalLayout, or TileLayout supports virtual layout. Layout subclasses that do not support virtualization must prevent changing this property.</p>  <p><b>Note: </b>The BasicLayout class throws a run-time error if you set <code>useVirtualLayout</code> to <code>true</code>.</p>  <p>When <code>true</code>, layouts that support virtualization must use the <code>target.getVirtualElementAt()</code> method, rather than <code>getElementAt()</code>, and must only get the elements they anticipate will be visible given the value of <code>getScrollRect()</code>.</p>  <p>When <code>true</code>, the layout class must be able to compute the indices of the layout elements that overlap the <code>scrollRect</code> in its <code>updateDisplayList()</code> method based exclusively on cached information, not by getting layout elements and examining their bounds.</p>  <p>Typically virtual layouts update their cached information in the <code>updateDisplayList()</code> method, based on the sizes and locations computed for the elements in view.</p>  <p>Similarly, in the <code>measure()</code> method, virtual layouts should update the target's measured size properties based on the <code>typicalLayoutElement</code> and other cached layout information, not by measuring elements.</p>  <p>Containers cooperate with layouts that have <code>useVirtualLayout</code> = <code>true</code> by recycling item renderers that were previously constructed, but are no longer in use. An item is considered to be no longer in use if its index is not within the range of <code>getVirtualElementAt()</code> indices requested during the container's most recent <code>updateDisplayList()</code> invocation.</p>",
        "tags": [
        {  "tagName": "default",
               "values": ["false"]},
            {  "tagName": "see",
               "values": ["#getScrollRect()", "#typicalLayoutElement"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "method",
        "qname": "clearVirtualLayoutCache",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "When <code>useVirtualLayout</code> is <code>true</code>, this method can be used by the layout target to clear cached layout information when the target changes.  <p>For example, when a DataGroup's <code>dataProvider</code> or <code>itemRenderer</code> property changes, cached elements sizes become invalid. </p>  <p>When the <code>useVirtualLayout</code> property changes to <code>false</code>, this method is called automatically.</p>  <p>Subclasses that support <code>useVirtualLayout</code> = <code>true</code> must override this method. </p>",
        "tags": [
        {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "void",
          "params": []}
      ,
      { "type": "accessor",
        "access": "read-only",
        "return": "Boolean",
        "qname": "virtualLayoutSupported",
        "namespace": "mx_internal",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Specifies whether this layout supports virtual layout.",
        "tags": [
        {  "tagName": "default",
               "values": ["true"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "Number",
        "qname": "horizontalScrollPosition",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "",
        "tags": [
        {  "tagName": "default",
               "values": ["0"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "copy",
               "values": ["spark.core.IViewport#horizontalScrollPosition"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "Number",
        "qname": "verticalScrollPosition",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "",
        "tags": [
        {  "tagName": "default",
               "values": ["0"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "copy",
               "values": ["spark.core.IViewport#verticalScrollPosition"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "Boolean",
        "qname": "clipAndEnableScrolling",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "",
        "tags": [
        {  "tagName": "default",
               "values": ["false"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "copy",
               "values": ["spark.core.IViewport#clipAndEnableScrolling"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "mx.core.ILayoutElement",
        "qname": "typicalLayoutElement",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Used by layouts when fixed row/column sizes are requested but a specific size isn't specified. Used by virtual layouts to estimate the size of layout elements that have not been scrolled into view.  <p>This property references a component that Flex uses to define the height of all container children, as the following example shows:</p>  <pre>\\n &lt;s:Group&gt;\\n &lt;s:layout&gt;\\n &lt;s:VerticalLayout variableRowHeight=&quot;false&quot;\\n typicalLayoutElement=&quot;{b3}&quot;/&gt;\\n &lt;/s:layout&gt;\\n &lt;s:Button id=&quot;b1&quot; label=&quot;Button 1&quot;/&gt;\\n &lt;s:Button id=&quot;b2&quot; label=&quot;Button 2&quot;/&gt;\\n &lt;s:Button id=&quot;b3&quot; label=&quot;Button 3&quot; fontSize=&quot;36&quot;/&gt;\\n &lt;s:Button id=&quot;b4&quot; label=&quot;Button 4&quot; fontSize=&quot;24&quot;/&gt;\\n &lt;/s:Group&gt;</pre>  <p>If this property has not been set and the target is non-null then the target's first layout element is cached and returned.</p>  <p>The default value is the target's first layout element.</p>",
        "tags": [
        {  "tagName": "default",
               "values": ["null"]},
            {  "tagName": "see",
               "values": ["#target", "spark.layouts.VerticalLayout#variableRowHeight", "spark.layouts.HorizontalLayout#variableColumnWidth"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "accessor",
        "access": "read-write",
        "return": "org.apache.royale.core.UIBase",
        "qname": "dropIndicator",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "The <code>DisplayObject</code> that this layout uses for the drop indicator during a drag-and-drop operation.  Typically you do not set this property directly, but instead define a <code>dropIndicator</code> skin part in the skin class of the drop target.  <p>The List control sets this property in response to a <code>DragEvent.DRAG_ENTER</code> event. The List initializes this property with an instance of its <code>dropIndicator</code> skin part. The List clears this property in response to a <code>DragEvent.DRAG_EXIT</code> event.</p>",
        "tags": [
        {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ]},
      { "type": "method",
        "qname": "measure",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Measures the target's default size based on its content, and optionally measures the target's default minimum size.  <p>This is one of the methods that you must override when creating a subclass of LayoutBase. The other method is <code>updateDisplayList()</code>. You do not call these methods directly. Flex calls this method as part of a layout pass. A layout pass consists of three phases.</p>  <p>First, if the target's properties are invalid, the LayoutManager calls the target's <code>commitProperties</code> method.</p>  <p>Second, if the target's size is invalid, LayoutManager calls the target's <code>validateSize()</code> method. The target's <code>validateSize()</code> will in turn call the layout's <code>measure()</code> to calculate the target's default size unless it was explicitly specified by both target's <code>explicitWidth</code> and <code>explicitHeight</code> properties. If the default size changes, Flex will invalidate the target's display list.</p>  <p>Last, if the target's display list is invalid, LayoutManager calls the target's <code>validateDisplayList</code>. The target's <code>validateDisplayList</code> will in turn call the layout's <code>updateDisplayList</code> method to size and position the target's elements.</p>  <p>When implementing this method, you must set the target's <code>measuredWidth</code> and <code>measuredHeight</code> properties to define the target's default size. You may optionally set the <code>measuredMinWidth</code> and <code>measuredMinHeight</code> properties to define the default minimum size. A typical implementation iterates through the target's elements and uses the methods defined by the <code>ILayoutElement</code> to accumulate the preferred and/or minimum sizes of the elements and then sets the target's <code>measuredWidth</code>, <code>measuredHeight</code>, <code>measuredMinWidth</code> and <code>measuredMinHeight</code>.</p>",
        "tags": [
        {  "tagName": "see",
               "values": ["#updateDisplayList()"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "void",
          "params": []}
      ,
      { "type": "method",
        "qname": "updateDisplayList",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Sizes and positions the target's elements.  <p>This is one of the methods that you must override when creating a subclass of LayoutBase. The other method is <code>measure()</code>. You do not call these methods directly. Flex calls this method as part of a layout pass. A layout pass consists of three phases.</p>  <p>First, if the target's properties are invalid, the LayoutManager calls the target's <code>commitProperties</code> method.</p>  <p>Second, if the target's size is invalid, LayoutManager calls the target's <code>validateSize()</code> method. The target's <code>validateSize()</code> will in turn call the layout's <code>measure()</code> to calculate the target's default size unless it was explicitly specified by both target's <code>explicitWidth</code> and <code>explicitHeight</code> properties. If the default size changes, Flex will invalidate the target's display list.</p>  <p>Last, if the target's display list is invalid, LayoutManager calls the target's <code>validateDisplayList</code>. The target's <code>validateDisplayList</code> will in turn call the layout's <code>updateDisplayList</code> method to size and position the target's elements.</p>  <p>A typical implementation iterates through the target's elements and uses the methods defined by the <code>ILayoutElement</code> to position and resize the elements. Then the layout must also calculate and set the target's <code>contentWidth</code> and <code>contentHeight</code> properties to define the target's scrolling region.</p>  in the targets's coordinates.  in the target's coordinates.",
        "tags": [
        {  "tagName": "see",
               "values": ["#measure()"]},
            {  "tagName": "param",
               "values": ["unscaledWidth Specifies the width of the target, in pixels,", "unscaledHeight Specifies the height of the component, in pixels,"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "void",
          "params": [{ "name": "width", "type": "Number"},
        { "name": "height", "type": "Number"}]}
      ,
      { "type": "method",
        "qname": "elementAdded",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Called by the target after a layout element has been added and before the target's size and display list are validated. Layouts that cache per element state, like virtual layouts, can override this method to update their cache.  <p>If the target calls this method, it's only guaranteeing that a a layout element will exist at the specified index at <code>updateDisplayList()</code> time, for example a DataGroup with a virtual layout will call this method when an item is added to the targets <code>dataProvider</code>.</p>  <p>By default, this method does nothing.</p>",
        "tags": [
        {  "tagName": "see",
               "values": ["#elementRemoved()"]},
            {  "tagName": "param",
               "values": ["index The index of the element that was added."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "void",
          "params": [{ "name": "index", "type": "int"}]}
      ,
      { "type": "method",
        "qname": "elementRemoved",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "This method must is called by the target after a layout element has been removed and before the target's size and display list are validated. Layouts that cache per element state, like virtual layouts, can override this method to update their cache.  <p>If the target calls this method, it's only guaranteeing that a a layout element will no longer exist at the specified index at <code>updateDisplayList()</code> time. For example, a DataGroup with a virtual layout calls this method when an item is added to the <code>dataProvider</code> property.</p>  <p>By default, this method does nothing.</p>",
        "tags": [
        {  "tagName": "see",
               "values": ["#elementAdded()"]},
            {  "tagName": "param",
               "values": ["index The index of the element that was added."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "void",
          "params": [{ "name": "index", "type": "int"}]}
      ,
      { "type": "method",
        "qname": "scrollPositionChanged",
        "namespace": "protected",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Called when the <code>verticalScrollPosition</code> or <code>horizontalScrollPosition</code> properties change.  <p>The default implementation updates the target's <code>scrollRect</code> property by calling <code>updateScrollRect()</code>. Subclasses can override this method to compute other values that are based on the current <code>scrollPosition</code> or <code>scrollRect</code>.</p>",
        "tags": [
        {  "tagName": "see",
               "values": ["#updateScrollRect()"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "void",
          "params": []}
      ,
      { "type": "method",
        "qname": "updateScrollRect",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Called by the target at the end of its <code>updateDisplayList</code> to have the layout update its scrollRect.  <p>If <code>clipAndEnableScrolling</code> is <code>true</code>, the default implementation sets the origin of the target's <code>scrollRect</code> to <code>verticalScrollPosition</code>, <code>horizontalScrollPosition</code>. It sets its size to the <code>width</code>, <code>height</code> parameters (the target's unscaled width and height).</p>  <p>If <code>clipAndEnableScrolling</code> is <code>false</code>, the default implementation sets the <code>scrollRect</code> to null.</p>",
        "tags": [
        {  "tagName": "see",
               "values": ["#target", "flash.display.DisplayObject#scrollRect", "#updateDisplayList()"]},
            {  "tagName": "param",
               "values": ["width The target's width.", "height The target's height."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "void",
          "params": [{ "name": "w", "type": "Number"},
        { "name": "h", "type": "Number"}]}
      ,
      { "type": "method",
        "qname": "getNavigationDestinationIndex",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Delegation method that determines which item to navigate to based on the current item in focus and user input in terms of NavigationUnit. This method is used by subclasses of ListBase to handle keyboard navigation. ListBase maps user input to NavigationUnit constants.  <p>Subclasses can override this method to compute other values that are based on the current index and key stroke encountered. </p>   which item to navigate to next.  navigate within the component wraps when it hits either end.  when if the layout doesn't recognize the navigationUnit.",
        "tags": [
        {  "tagName": "param",
               "values": ["currentIndex The current index of the item with focus.", "navigationUnit The NavigationUnit constant that determines", "arrowKeysWrapFocus If <code>true</code>, using arrow keys to"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The index of the next item to jump to. Returns -1"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "int",
          "params": [{ "name": "currentIndex", "type": "int"},
        { "name": "navigationUnit", "type": "uint"},
        { "name": "arrowKeysWrapFocus", "type": "Boolean"}]}
      ,
      { "type": "method",
        "qname": "getScrollRect",
        "namespace": "protected",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Returns the bounds of the target's scroll rectangle in layout coordinates.  Layout methods should not get the target's scroll rectangle directly.  if target or clipAndEnableScrolling is false.",
        "tags": [
        {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The bounds of the target's scrollRect in layout coordinates, null"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "org.apache.royale.geom.Rectangle",
          "params": []}
      ,
      { "type": "method",
        "qname": "getElementBounds",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Returns the specified element's layout bounds as a Rectangle or null if the index is invalid, the corresponding element is null, <code>includeInLayout=false</code>, or if this layout's <code>target</code> property is null.  <p>Layout subclasses that support <code>useVirtualLayout=true</code> must override this method to compute a potentially approximate value for elements that are not in view.</p>",
        "tags": [
        {  "tagName": "see",
               "values": ["mx.core.ILayoutElement#getLayoutBoundsX()", "mx.core.ILayoutElement#getLayoutBoundsY()", "mx.core.ILayoutElement#getLayoutBoundsWidth()", "mx.core.ILayoutElement#getLayoutBoundsHeight()"]},
            {  "tagName": "param",
               "values": ["index Index of the layout element."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The specified element's layout bounds."]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "org.apache.royale.geom.Rectangle",
          "params": [{ "name": "index", "type": "int"}]}
      ,
      { "type": "method",
        "qname": "getElementBoundsLeftOfScrollRect",
        "namespace": "protected",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Returns the bounds of the first layout element that either spans or is to the left of the scrollRect's left edge.  <p>This is a convenience method that is used by the default implementation of the <code>getHorizontalScrollPositionDelta()</code> method. Subclasses that rely on the default implementation of <code>getHorizontalScrollPositionDelta()</code> should override this method to provide an accurate bounding rectangle that has valid <code>left</code> and <code>right</code> properties.</p>  <p>By default this method returns a Rectangle with width=1, height=0, whose left edge is one less than the left edge of the <code>scrollRect</code>, and top=0.</p>   the left of the scrollRect's left edge.",
        "tags": [
        {  "tagName": "see",
               "values": ["#getElementBoundsRightOfScrollRect()", "#getElementBoundsAboveScrollRect()", "#getElementBoundsBelowScrollRect()", "#getHorizontalScrollPositionDelta()"]},
            {  "tagName": "param",
               "values": ["scrollRect The target's scrollRect."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The bounds of the first element that spans or is to"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "org.apache.royale.geom.Rectangle",
          "params": [{ "name": "scrollRect", "type": "org.apache.royale.geom.Rectangle"}]}
      ,
      { "type": "method",
        "qname": "getElementBoundsRightOfScrollRect",
        "namespace": "protected",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Returns the bounds of the first layout element that either spans or is to the right of the scrollRect's right edge.  <p>This is a convenience method that is used by the default implementation of the <code>getHorizontalScrollPositionDelta()</code> method. Subclasses that rely on the default implementation of <code>getHorizontalScrollPositionDelta()</code> should override this method to provide an accurate bounding rectangle that has valid <code>left</code> and <code>right</code> properties.</p>  <p>By default this method returns a Rectangle with width=1, height=0, whose right edge is one more than the right edge of the <code>scrollRect</code>, and top=0.</p>   the right of the scrollRect's right edge.",
        "tags": [
        {  "tagName": "see",
               "values": ["#getElementBoundsLeftOfScrollRect()", "#getElementBoundsAboveScrollRect()", "#getElementBoundsBelowScrollRect()", "#getHorizontalScrollPositionDelta()"]},
            {  "tagName": "param",
               "values": ["scrollRect The target's scrollRect."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The bounds of the first element that spans or is to"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "org.apache.royale.geom.Rectangle",
          "params": [{ "name": "scrollRect", "type": "org.apache.royale.geom.Rectangle"}]}
      ,
      { "type": "method",
        "qname": "getElementBoundsAboveScrollRect",
        "namespace": "protected",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Returns the bounds of the first layout element that either spans or is above the scrollRect's top edge.  <p>This is a convenience method that is used by the default implementation of the <code>getVerticalScrollPositionDelta()</code> method. Subclasses that rely on the default implementation of <code>getVerticalScrollPositionDelta()</code> should override this method to provide an accurate bounding rectangle that has valid <code>top</code> and <code>bottom</code> properties.</p>  <p>By default this method returns a Rectangle with width=0, height=1, whose top edge is one less than the top edge of the <code>scrollRect</code>, and left=0.</p>  <p>Subclasses should override this method to provide an accurate bounding rectangle that has valid <code>top</code> and <code>bottom</code> properties.</p>   above the scrollRect's top edge.",
        "tags": [
        {  "tagName": "see",
               "values": ["#getElementBoundsLeftOfScrollRect()", "#getElementBoundsRightOfScrollRect()", "#getElementBoundsBelowScrollRect()", "#getVerticalScrollPositionDelta()"]},
            {  "tagName": "param",
               "values": ["scrollRect The target's scrollRect."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The bounds of the first element that spans or is"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "org.apache.royale.geom.Rectangle",
          "params": [{ "name": "scrollRect", "type": "org.apache.royale.geom.Rectangle"}]}
      ,
      { "type": "method",
        "qname": "getElementBoundsBelowScrollRect",
        "namespace": "protected",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Returns the bounds of the first layout element that either spans or is below the scrollRect's bottom edge.  <p>This is a convenience method that is used by the default implementation of the <code>getVerticalScrollPositionDelta()</code> method. Subclasses that rely on the default implementation of <code>getVerticalScrollPositionDelta()</code> should override this method to provide an accurate bounding rectangle that has valid <code>top</code> and <code>bottom</code> properties.</p>  <p>By default this method returns a Rectangle with width=0, height=1, whose bottom edge is one more than the bottom edge of the <code>scrollRect</code>, and left=0.</p>   below the scrollRect's bottom edge.",
        "tags": [
        {  "tagName": "see",
               "values": ["#getElementBoundsLeftOfScrollRect()", "#getElementBoundsRightOfScrollRect()", "#getElementBoundsAboveScrollRect()", "#getVerticalScrollPositionDelta()"]},
            {  "tagName": "param",
               "values": ["scrollRect The target's scrollRect."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The bounds of the first element that spans or is"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "org.apache.royale.geom.Rectangle",
          "params": [{ "name": "scrollRect", "type": "org.apache.royale.geom.Rectangle"}]}
      ,
      { "type": "method",
        "qname": "getHorizontalScrollPositionDelta",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Returns the change to the horizontal scroll position to handle different scrolling options. These options are defined by the NavigationUnit class: <code>END</code>, <code>HOME</code>, <code>LEFT</code>, <code>PAGE_LEFT</code>, <code>PAGE_RIGHT</code>, and <code>RIGHT</code>.  <ul> <li> <code>END</code> Returns scroll delta that will right justify the scrollRect to the content area. </li>  <li> <code>HOME</code> Returns scroll delta that will left justify the scrollRect to the content area. </li>  <li> <code>LEFT</code> Returns scroll delta that will left justify the scrollRect with the first element that spans or is to the left of the scrollRect's left edge. </li>  <li> <code>PAGE_LEFT</code> Returns scroll delta that will right justify the scrollRect with the first element that spans or is to the left of the scrollRect's left edge. </li>  <li> <code>PAGE_RIGHT</code> Returns scroll delta that will left justify the scrollRect with the first element that spans or is to the right of the scrollRect's right edge. </li>  <li> <code>RIGHT</code> Returns scroll delta that will right justify the scrollRect with the first element that spans or is to the right of the scrollRect's right edge. </li>  </ul>  <p>The implementation calls <code>getElementBoundsLeftOfScrollRect()</code> and <code>getElementBoundsRightOfScrollRect()</code> to determine the bounds of the elements.  Layout classes usually override those methods instead of the <code>getHorizontalScrollPositionDelta()</code> method.</p>",
        "tags": [
        {  "tagName": "see",
               "values": ["spark.core.NavigationUnit", "#getElementBoundsLeftOfScrollRect()", "#getElementBoundsRightOfScrollRect()", "#getHorizontalScrollPositionDelta()"]},
            {  "tagName": "param",
               "values": ["navigationUnit Takes the following values:"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The change to the horizontal scroll position."]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "Number",
          "params": [{ "name": "navigationUnit", "type": "uint"}]}
      ,
      { "type": "method",
        "qname": "getVerticalScrollPositionDelta",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Returns the change to the vertical scroll position to handle different scrolling options. These options are defined by the NavigationUnit class: <code>DOWN</code>,  <code>END</code>, <code>HOME</code>, <code>PAGE_DOWN</code>, <code>PAGE_UP</code>, and <code>UP</code>.  <ul> <li> <code>DOWN</code> Returns scroll delta that will bottom justify the scrollRect with the first element that spans or is below the scrollRect's bottom edge. </li>  <li> <code>END</code> Returns scroll delta that will bottom justify the scrollRect to the content area. </li>  <li> <code>HOME</code> Returns scroll delta that will top justify the scrollRect to the content area. </li>  <li> <code>PAGE_DOWN</code> Returns scroll delta that will top justify the scrollRect with the first element that spans or is below the scrollRect's bottom edge. </li>  <code>PAGE_UP</code> <li> Returns scroll delta that will bottom justify the scrollRect with the first element that spans or is above the scrollRect's top edge. </li>  <li> <code>UP</code> Returns scroll delta that will top justify the scrollRect with the first element that spans or is above the scrollRect's top edge. </li>  </ul>  <p>The implementation calls <code>getElementBoundsAboveScrollRect()</code> and <code>getElementBoundsBelowScrollRect()</code> to determine the bounds of the elements. Layout classes usually override those methods instead of the <code>getVerticalScrollPositionDelta()</code> method. </p>",
        "tags": [
        {  "tagName": "see",
               "values": ["spark.core.NavigationUnit", "#getElementBoundsAboveScrollRect()", "#getElementBoundsBelowScrollRect()", "#getVerticalScrollPositionDelta()"]},
            {  "tagName": "param",
               "values": ["navigationUnit Takes the following values:"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The change to the vertical scroll position."]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "Number",
          "params": [{ "name": "navigationUnit", "type": "uint"}]}
      ,
      { "type": "method",
        "qname": "getScrollPositionDeltaToElement",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Computes the <code>verticalScrollPosition</code> and <code>horizontalScrollPosition</code> deltas needed to scroll the element at the specified index into view.  <p>This method attempts to minimize the change to <code>verticalScrollPosition</code> and <code>horizontalScrollPosition</code>.</p>  <p>If <code>clipAndEnableScrolling</code> is <code>true</code> and the element at the specified index is not entirely visible relative to the target's scroll rectangle, then return the delta to be added to <code>horizontalScrollPosition</code> and <code>verticalScrollPosition</code> that scrolls the element completely within the scroll rectangle's bounds.</p>   and verticalScrollPosition that will scroll the specified element into view, or null if no change is needed. If the specified element is partially visible and larger than the scroll rectangle, meaning it is already the only element visible, then return null. If the specified index is invalid, or target is null, then return null. If the element at the specified index is null or includeInLayout false, then return null.",
        "tags": [
        {  "tagName": "see",
               "values": ["#clipAndEnableScrolling", "#verticalScrollPosition", "#horizontalScrollPosition", "#updateScrollRect()"]},
            {  "tagName": "param",
               "values": ["index The index of the element to be scrolled into view."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["A Point that contains offsets to horizontalScrollPosition"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "org.apache.royale.geom.Point",
          "params": [{ "name": "index", "type": "int"}]}
      ,
      { "type": "field",
        "qname": "dragScrollRegionSizeHorizontal",
        "return": "Number",
        "namespace": "mx_internal",
        "bindable": [],
        "details": [],
        "deprecated": {}},
      { "type": "field",
        "qname": "dragScrollRegionSizeVertical",
        "return": "Number",
        "namespace": "mx_internal",
        "bindable": [],
        "details": [],
        "deprecated": {}},
      { "type": "field",
        "qname": "dragScrollSpeed",
        "return": "Number",
        "namespace": "mx_internal",
        "bindable": [],
        "details": [],
        "deprecated": {}},
      { "type": "field",
        "qname": "dragScrollInitialDelay",
        "return": "int",
        "namespace": "mx_internal",
        "bindable": [],
        "details": [],
        "deprecated": {}},
      { "type": "field",
        "qname": "dragScrollInterval",
        "return": "int",
        "namespace": "mx_internal",
        "bindable": [],
        "details": [],
        "deprecated": {}},
      { "type": "field",
        "qname": "dragScrollHidesIndicator",
        "return": "Boolean",
        "namespace": "mx_internal",
        "bindable": [],
        "details": [],
        "deprecated": {}},
      { "type": "method",
        "qname": "calculateDropLocation",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Calculates the drop location in the data provider of the drop target for the specified <code>dragEvent</code>.   operation is not available.",
        "tags": [
        {  "tagName": "see",
               "values": ["#showDropIndicator()", "#hideDropIndicator()"]},
            {  "tagName": "param",
               "values": ["dragEvent The drag event dispatched by the DragManager."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["Returns the drop location for this event, or null if the drop"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "spark.layouts.supportClasses.DropLocation",
          "params": [{ "name": "dragEvent", "type": "mx.events.DragEvent"}]}
      ,
      { "type": "method",
        "qname": "showDropIndicator",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Sizes, positions and parents the drop indicator based on the specified drop location. Use the <code>calculateDropLocation()</code> method to obtain the DropLocation object.  <p>Starts/stops drag-scrolling when necessary conditions are met.</p>  Drop location is obtained through the <code>computeDropLocation()</code> method.",
        "tags": [
        {  "tagName": "see",
               "values": ["#dropIndicator", "#hideDropIndicator()"]},
            {  "tagName": "param",
               "values": ["dropLocation Specifies the location where to show the drop indicator."]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "void",
          "params": [{ "name": "dropLocation", "type": "spark.layouts.supportClasses.DropLocation"}]}
      ,
      { "type": "method",
        "qname": "hideDropIndicator",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Hides the previously shown drop indicator, created by the <code>showDropIndicator()</code> method, removes it from the display list and also stops the drag scrolling.",
        "tags": [
        {  "tagName": "see",
               "values": ["#showDropIndicator()", "#dropIndicator"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "void",
          "params": []}
      ,
      { "type": "method",
        "qname": "calculateDropIndex",
        "namespace": "protected",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Returns the index where a new item should be inserted if the user releases the mouse at the specified coordinates while completing a drag and drop gesture.  Called by the <code>calculatedDropLocation()</code> method.  local coordinates.  the drop target's local coordinates.  at the specified coordinates.",
        "tags": [
        {  "tagName": "see",
               "values": ["#calculateDropLocation()"]},
            {  "tagName": "param",
               "values": ["x The x coordinate of the drag and drop gesture, in", "y The y coordinate of the drag and drop gesture, in"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The drop index or -1 if the drop operation is not available"]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "int",
          "params": [{ "name": "x", "type": "Number"},
        { "name": "y", "type": "Number"}]}
      ,
      { "type": "method",
        "qname": "calculateDropIndicatorBounds",
        "namespace": "protected",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "description": "Calculates the bounds for the drop indicator that provides visual feedback to the user of where the items will be inserted at the end of a drag and drop gesture.  Called by the <code>showDropIndicator()</code> method.  by the <code>calculateDropLocation()</code> method.",
        "tags": [
        {  "tagName": "see",
               "values": ["spark.layouts.supportClasses.DropLocation", "#calculateDropIndex()", "#calculateDragScrollDelta()"]},
            {  "tagName": "param",
               "values": ["dropLocation A valid DropLocation object previously returned"]},
            {  "tagName": "playerversion",
               "values": ["Flash 10", "AIR 1.5"]},
            {  "tagName": "productversion",
               "values": ["Flex 4"]},
            {  "tagName": "return",
               "values": ["The bounds for the drop indicator or null."]},
            {  "tagName": "langversion",
               "values": ["3.0"]}  ],
          "return": "org.apache.royale.geom.Rectangle",
          "params": [{ "name": "dropLocation", "type": "spark.layouts.supportClasses.DropLocation"}]}
      ,
      { "type": "method",
        "qname": "hasEventListener",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "return": "Boolean",
          "params": [{ "name": "type", "type": "String"}]}
      ,
      { "type": "method",
        "qname": "dispatchEvent",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "return": "Boolean",
          "params": [{ "name": "event", "type": "Object"}]}
      ,
      { "type": "method",
        "qname": "addEventListener",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "return": "void",
          "params": [{ "name": "type", "type": "String"},
        { "name": "handler", "type": "Function"},
        { "name": "opt_capture", "type": "Boolean"},
        { "name": "opt_handlerScope", "type": "Object"}]}
      ,
      { "type": "method",
        "qname": "removeEventListener",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "return": "void",
          "params": [{ "name": "type", "type": "String"},
        { "name": "handler", "type": "Function"},
        { "name": "opt_capture", "type": "Boolean"},
        { "name": "opt_handlerScope", "type": "Object"}]}
      ,
      { "type": "method",
        "qname": "layout",
        "namespace": "public",
        "bindable": [],
        "details": ["override"],
        "deprecated": {},
          "return": "Boolean",
          "params": []}
      ,
      { "type": "method",
        "qname": "isHeightSizedToContent",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "return": "Boolean",
          "params": []}
      ,
      { "type": "method",
        "qname": "isWidthSizedToContent",
        "namespace": "public",
        "bindable": [],
        "details": [],
        "deprecated": {},
          "return": "Boolean",
          "params": []}
      ]
  }
